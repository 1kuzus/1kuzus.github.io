1:HL["/_next/static/css/8ac0b0e7f508d966.css","style",{"crossOrigin":""}]
0:["a2ccQY1j6x_FTv2AsGrpW",[[["",{"children":["(blogs)",{"children":["24a",{"children":["object-oriented-programming-python",{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/8ac0b0e7f508d966.css","precedence":"next","crossOrigin":""}]],"$L3"]]]]
4:HL["/_next/static/css/c84b60895b980f14.css","style",{"crossOrigin":""}]
5:HL["/_next/static/css/f70c26425a044d6b.css","style",{"crossOrigin":""}]
6:I[9226,["185","static/chunks/app/layout-e12e822557cc964c.js"],"GlobalProvider"]
7:I[9330,["185","static/chunks/app/layout-e12e822557cc964c.js"],""]
8:I[6954,[],""]
9:I[7264,[],""]
a:I[5285,["176","static/chunks/176-6509553bec92a789.js","135","static/chunks/app/(blogs)/layout-75f88dfdcbd0ba18.js"],""]
c:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],"Title"]
d:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],"H1"]
e:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],"H2"]
f:I[9708,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],""]
10:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],"H3"]
11:I[8411,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],""]
12:I[8275,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","202","static/chunks/202-7b9f876bcb1bf7b4.js","481","static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-632caa49db4fb8b4.js"],"Uli"]
13:T448,
                class Vector3d:
                    ...

                    # 重载加号运算符，obj1+obj2时调用
                    def __add__(self, other):
                        return Vector3d(self.x + other.x, self.y + other.y, self.z + other.z)

                    # 重载减号运算符，obj1-obj2时调用
                    def __sub__(self, other):
                        return Vector3d(self.x - other.x, self.y - other.y, self.z - other.z)

                    # 重载乘号运算符
                    def __mul__(self, other):
                        if isinstance(other, (int, float)):
                            return Vector3d(self.x * other, self.y * other, self.z * other)
                        else:
                            return self.x * other.x + self.y * other.y + self.z * other.z

                print(v1)  # (3, 4, 5)
                print(v2)  # (2, -2, 1)
                print(v1 + v2)  # (5, 2, 6)
                print(v1 - v2)  # (1, 6, 4)
                print(v1 * v2)  # 3
                print(v1 * 2)  # (6, 8, 10)
                2:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L6",null,{"children":[["$","$L7",null,{}],["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":[null,["$","$La",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children","24a","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children","24a","children","object-oriented-programming-python","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$Lb",[["$","$Lc",null,{"children":"$undefined"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"本文对面向对象的基本理论（为什么要有类、什么是属性、什么是方法等）不多做解释，重点在Python中的编程实现。"}}],["$","$Ld",null,{"children":"基本操作"}],["$","$Le",null,{"children":"定义一个类"}],["$","$Lf",null,{"language":"python","highlightLines":"3-7","code":"\n                class Unit:\n                    # 初始化方法/构造函数\n                    def __init__(self, name, hp, damage):\n                        # 实例属性\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    # 实例方法\n                    def sayhi(self):\n                        print(f\"hi, I'm {self.name}\")\n\n                u1 = Unit(\"u1\", 100, 20)\n                u2 = Unit(\"u2\", 200, 10)\n\n                u1.sayhi()  # Hi, I'm u1\n                print(u1.hp)  # 100\n                print(u1.damage)  # 20\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上面的代码定义了一个<code class=\"x-inline-highlight\">Unit</code>类，这个例子中暂且理解为一个游戏中的作战单位，每个单位具有名字<code class=\"x-inline-highlight\">name</code>、生命值<code class=\"x-inline-highlight\">hp</code>、攻击力<code class=\"x-inline-highlight\">damage</code>这些属性。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">__init__</code>方法称作类的<span class=\"x-inline-strong\">初始化方法</span>/<span class=\"x-inline-strong\">构造函数</span>，实例本身会作为函数的第一个参数<code class=\"x-inline-highlight\">self</code>被传入。从这个角度理解，实际上<code class=\"x-inline-highlight\">__init__</code>方法是将传入的参数“绑定”到新创建的实例上。"}}],["$","$Le",null,{"children":"类属性和实例属性"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们在类下直接定义了一个属性<code class=\"x-inline-highlight\">utype</code>，它是一个<code class=\"x-inline-highlight\">类属性</code>；与之对应的是<code class=\"x-inline-highlight\">__init__</code>方法为实例创建的属性，我们称之为<code class=\"x-inline-highlight\">实例属性</code>。"}}],["$","$Lf",null,{"language":"python","highlightLines":"3","code":"\n                class Unit:\n                    # 类属性，占用同一块地址\n                    utype = \"unit\"\n\n                    def __init__(self, name, hp, damage):\n                        # 实例属性，独属于每个实例\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    def sayhi(self):\n                        print(\"hi, I'm %s\" % self.name)\n\n                u1 = Unit(\"u1\", 100, 20)\n                u2 = Unit(\"u2\", 200, 10)\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"访问实例属性时，把它们当作普通变量就好了；实例属性也可以在<code class=\"x-inline-highlight\">__init__</code>方法之外动态的添加。"}}],["$","$Lf",null,{"language":"python","code":"\n                print(u1.hp)  # 100\n                print(u1.damage)  # 20\n                u1.level = 1\n                print(u1.level)  # 1\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"类属性可以在类上取得，也可以在实例上取得。类属性共享内存地址。"}}],["$","$Lf",null,{"language":"python","code":"\n                print(Unit.utype, u1.utype, u2.utype)  # unit unit unit\n                print(id(Unit.utype))  # 2197356757808\n                print(id(u1.utype))    # 2197356757808\n                print(id(u2.utype))    # 2197356757808\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"由于共享内存地址，因此修改类属性具有全局性："}}],["$","$Lf",null,{"language":"python","code":"\n                Unit.utype = \"spell\"\n                print(Unit.utype, u1.utype, u2.utype)  # spell spell spell\n                "}],["$","div",null,{"className":"x-highlightblock highlight-background-golden","children":[["$","$L10",null,{"children":"注意"}],["$","$Lf",null,{"language":"python","code":"\n                    u1.utype = \"hero\"\n                    print(Unit.utype, u1.utype, u2.utype)  # spell hero spell\n                    "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例属性。上面的例子相当于给<code class=\"x-inline-highlight\">u1</code>添加了一个与类属性同名实例属性，<code class=\"x-inline-highlight\">u1.utype</code>访问到的不是类属性。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"要想访问<code class=\"x-inline-highlight\">u1</code>的类属性，可以通过<code class=\"x-inline-highlight\">__class__</code>访问："}}],["$","$Lf",null,{"language":"python","code":"print(u1.__class__.utype)  # spell"}]]}],["$","$Ld",null,{"children":"继承"}],["$","$Le",null,{"children":"实现一个子类"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们还是定义一个<code class=\"x-inline-highlight\">Unit</code>类，并实现两个方法：<code class=\"x-inline-highlight\">info</code>用于输出自身基本信息，<code class=\"x-inline-highlight\">attack</code>模拟攻击另一个单位。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Unit:\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    def info(self):\n                        print(f\"name: {self.name}, hp: {self.hp}, damage: {self.damage}\")\n\n                    def attack(self, unit):\n                        unit.hp -= self.damage\n                        print(f\"{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}\")\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"现在我们希望实现一个<code class=\"x-inline-highlight\">GroundUnit</code>类，表示地面单位，并且地面单位具有特有的伤害加成，用属性<code class=\"x-inline-highlight\">buff</code>定义。显然，会有大量的逻辑与<code class=\"x-inline-highlight\">Unit</code>类是重复的。这时可以通过继承来实现："}}],["$","$Lf",null,{"language":"python","highlightLines":"3","code":"\n                class GroundUnit(Unit):\n                    def __init__(self, name, hp, damage, buff):\n                        super().__init__(name, hp, damage)\n                        # 子类新增的实例属性\n                        self.buff = buff\n\n                    # 重写父类方法\n                    def attack(self, unit):\n                        unit.hp -= self.damage * (1 + self.buff)\n                        print(f\"{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}\")\n\n                gu1 = GroundUnit(\"gu1\", 100, 20, 0.2)\n                gu2 = GroundUnit(\"gu2\", 200, 10, 0.2)\n\n                gu2.info()  # name: gu2, hp: 200, damage: 10\n                gu1.attack(gu2)  # gu1 attacks gu2, gu2.hp = 176.0\n                gu2.info()  # name: gu2, hp: 176.0, damage: 10\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"定义类时，用<code class=\"x-inline-highlight\">class 子类(父类):</code>表示继承。如果子类有自己的构造函数，会覆盖父类的构造函数；否则会继承父类的构造函数。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"代码中<code class=\"x-inline-highlight\">super()</code>函数可以找到父类，高亮的代码等价于<code class=\"x-inline-highlight\">Unit.__init__(self, name, hp, damage)</code>。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"如果子类需要对父类的方法进行重写，只需要在子类下定义同名方法，然后重写逻辑。其他父类的方法会被继承到子类中，例如这个例子中的<code class=\"x-inline-highlight\">info()</code>。"}}],["$","$Le",null,{"children":"isinstance函数"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">isinstance(实例,类)</code>可以判断一个实例是否属于给定的类。<span class=\"x-inline-strong\">子类的实例同时也是父类的实例</span>。"}}],["$","$Lf",null,{"language":"python","code":"\n                u1 = Unit(\"u1\", 100, 20)\n                gu1 = GroundUnit(\"gu1\", 100, 20, 0.2)\n\n                print(isinstance(u1, Unit))         # True\n                print(isinstance(u1, GroundUnit))   # False\n                print(isinstance(gu1, Unit))        # True\n                print(isinstance(gu1, GroundUnit))  # True\n                "}],["$","$Le",null,{"children":"多继承"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"假设我们的游戏复杂起来，引入了稀有度系统，每个单位有一个所属的稀有度，例如普通、稀有、史诗、传奇等等。以史诗级为例，假设对于这些不同稀有度的单位有着其他独特的机制，以至于我们不得不新创建一个<code class=\"x-inline-highlight\">EpicRarity</code>类："}}],["$","$Lf",null,{"language":"python","code":"\n                class EpicRarity:\n                    def __init__(self, level):\n                        self.level = level\n\n                    def info(self):\n                        print(f\"This is a lv.{self.level} epic unit\")\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"当然，为了便于演示，我们只定义了一个<code class=\"x-inline-highlight\">level</code>属性和<code class=\"x-inline-highlight\">info</code>方法。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"现在，我们想实现<code class=\"x-inline-highlight\">EpicGroundUnit</code>子类，表示史诗级地面单位。显然它需要同时继承父类<code class=\"x-inline-highlight\">EpicRarity</code>和<code class=\"x-inline-highlight\">GroundUnit</code>，这就是<span class=\"x-inline-strong\">多继承</span>。"}}],["$","$Lf",null,{"language":"python","highlightLines":"3-4","code":"\n                class EpicGroundUnit(EpicRarity, GroundUnit):\n                    def __init__(self, name, hp, damage, buff, level):\n                        GroundUnit.__init__(self, name, hp, damage, buff)\n                        EpicRarity.__init__(self, level)\n\n                egu1 = EpicGroundUnit(\"egu1\", 100, 20, 0.2, 1)\n\n                egu1.info()  # This is a lv.1 epic unit\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在构造函数中我们需要分别对父类进行初始化。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"注意到两个父类都实现了<code class=\"x-inline-highlight\">info</code>方法并且没有被子类重写。调用之后我们发现，子类继承的是<code class=\"x-inline-highlight\">EpicRarity</code>的<code class=\"x-inline-highlight\">info</code>方法。如果代码改写为："}}],["$","$Lf",null,{"language":"python","highlightLines":"1","code":"\n                class EpicGroundUnit(GroundUnit, EpicRarity):\n                    def __init__(self, name, hp, damage, buff, level):\n                        GroundUnit.__init__(self, name, hp, damage, buff)\n                        EpicRarity.__init__(self, level)\n\n                egu1 = EpicGroundUnit(\"egu1\", 100, 20, 0.2, 1)\n\n                egu1.info()  # name: egu1, hp: 100, damage: 20\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"就会发现，调换父类的顺序后，现在子类继承的是<code class=\"x-inline-highlight\">GroundUnit</code>的<code class=\"x-inline-highlight\">info</code>方法。这就引出了下一节的内容：<span class=\"x-inline-strong\">方法解析顺序</span>。"}}],["$","$Le",null,{"children":"方法解析顺序MRO"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"对于多继承情况下的同名方法，如何从父类中找应该优先使用哪个父类的方法就叫<span class=\"x-inline-strong\">方法解析顺序</span><code class=\"x-inline-highlight\">(Method Resolution Order, MRO)</code>。 Python采用<a href=\"https://zh.wikipedia.org/zh-cn/C3%E7%BA%BF%E6%80%A7%E5%8C%96\" target=\"_blank\" rel=\"noreferrer\" class=\"x-inline-link\">C3线性化</a>算法来计算线性化列表，保证继承顺序列表中每个类只出现一次。"}}],["$","$Lf",null,{"language":"python","code":"\n                class A:\n                    def test(self):\n                        print('A')\n\n                class B:\n                    def test(self):\n                        print('B')\n\n                class C(A, B):\n                    pass\n\n                class D(C, B):\n                    pass\n\n                obj = D()\n                obj.test()  # A\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上述代码描述了一个如下图所示的复杂继承关系："}}],["$","$L11",null,{"src":{"default":{"src":"/_next/static/media/mro.39176437.jpg","height":374,"width":505,"blurDataURL":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAYACAMBIgACEQEDEQH/xAAnAAEBAAAAAAAAAAAAAAAAAAAABwEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAAr4P/xAAZEAACAwEAAAAAAAAAAAAAAAABAgARQVH/2gAIAQEAAT8AdQK4cn//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAECAQE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AH//2Q==","blurWidth":8,"blurHeight":6}},"width":"300px","invertInDarkTheme":true}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"可以通过<code class=\"x-inline-highlight\">mro()</code>函数得到类的方法解析顺序："}}],["$","$Lf",null,{"language":"python","code":"\n                # 注意是类名，不是实例名\n                print(D.mro())  # [<class '__main__.D'>, <class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"输出的列表中，从左到右的顺序为查找方法的顺序。上述例子中，<code class=\"x-inline-highlight\">D</code>和<code class=\"x-inline-highlight\">C</code>类都没有定义<code class=\"x-inline-highlight\">test</code>方法，因此顺次使用了<code class=\"x-inline-highlight\">A</code>类的<code class=\"x-inline-highlight\">test</code>方法。"}}],["$","div",null,{"className":"x-highlightblock highlight-background-golden","children":[["$","$L10",null,{"children":"注意"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"MRO顺序不是简单的深度优先或广度优先！"}}]]}],["$","$Ld",null,{"children":"封装"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在前面<code class=\"x-inline-highlight\">Unit</code>类的例子中，我们可以通过直接访问<code class=\"x-inline-highlight\">u1.hp</code>修改其值，这样并不安全（这岂不是像外挂一样）！<span class=\"x-inline-strong\">封装</span>的目的是为了保护数据，不让外部直接访问和修改。在Python中，约定通过在属性名称前加两个下划线<code class=\"x-inline-highlight\">__</code>来将属性私有化。这种命名约定会使Python解释器修改变量名为<code class=\"x-inline-highlight\">_类名__属性名</code>的形式，使其在类外部变得难以访问。"}}],["$","$Le",null,{"children":"将实例属性私有化"}],["$","$Lf",null,{"language":"python","highlightLines":"5-6","code":"\n                class Unit:\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        # 私有属性\n                        self.__hp = hp\n                        self.__damage = damage\n\n                    def attack(self, unit):\n                        unit.__hp -= self.__damage\n                        print(f\"{self.name} attacks {unit.name}, {unit.name}.__hp = {unit.__hp}\")\n\n                    # 通过公有方法访问私有属性\n                    def get_hp(self):\n                        return self.__hp\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在定义私有属性后，对外开放一个公有方法<code class=\"x-inline-highlight\">get_hp</code>，通过这个公有方法可以间接的访问到<code class=\"x-inline-highlight\">__hp</code>属性。这样相当于让此属性对外部“只读”。"}}],["$","$Lf",null,{"language":"python","code":"\n                u1 = Unit(\"u1\", 100, 20)\n                print(u1.get_hp())  # 100\n                print(u1.__hp)  # AttributeError: 'Unit' object has no attribute '__hp'\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"通过<code class=\"x-inline-highlight\">_类名__属性名</code>的形式可以强制访问私有属性："}}],["$","$Lf",null,{"language":"python","code":"print(u1._Unit__hp)  # 100"}],["$","div",null,{"className":"x-highlightblock highlight-background-golden","children":[["$","$L10",null,{"children":"注意"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在类外绑定的双下划线变量是公有的。"}}],["$","$Lf",null,{"language":"python","code":"\n                    u1.__var = 1\n                    print(u1.__var)  # 1\n                    "}]]}],["$","$Le",null,{"children":"类比于C++"}],["$","p",null,{"className":"x-p no-margin-bottom","dangerouslySetInnerHTML":{"__html":"C++中的封装有三种：<code class=\"x-inline-highlight\">public</code>、<code class=\"x-inline-highlight\">protected</code>、<code class=\"x-inline-highlight\">private</code>；Python中没有这些关键字，但是可以通过属性名命名约定来实现。"}}],["$","$L12",null,{"children":"`public`：公有变量，可以在*类的内部和外部*访问，正常命名即可。"}],["$","$L12",null,{"children":"`protected`：保护变量，只能在*类内和子类*访问，属性名前加单下划线`_`。这只是一种命名约定，实际上是可以访问的。"}],["$","$L12",null,{"children":"`private`：私有变量，只能在*类的内部*访问，属性名前加双下划线`__`，这样会使Python解释器修改变量名为`_类名__属性名`的形式。"}],["$","$Lf",null,{"language":"python","code":"\n                class A:\n                    def __init__(self, x, y, z):\n                        # 公有变量\n                        self.x = x\n                        # 保护变量\n                        self._y = y\n                        # 私有变量\n                        self.__z = z\n\n                class B(A):\n                    def __init__(self, x, y, z):\n                        super().__init__(x, y, z)\n\n                    def info_x(self):\n                        print(f\"x: {self.x}\")\n\n                    def info_y(self):\n                        print(f\"y: {self._y}\")\n\n                    def info_z(self):\n                        print(f\"z: {self.__z}\")\n\n                b = B(1, 2, 3)\n                b.info_x()  # x: 1\n                b.info_y()  # y: 2\n                b.info_z()  # AttributeError: 'B' object has no attribute '_B__z'. Did you mean: '_A__z'?\n                "}],["$","div",null,{"className":"x-highlightblock highlight-background-golden","children":[["$","$L10",null,{"children":"注意"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"C++中的<code class=\"x-inline-highlight\">protected</code>关键字是一种严格的访问控制机制，而Python中的单下划线变量只是一种命名约定，不具有强制性，实际上是可以访问的。只不过有时违反了这样的约定时，有些代码编辑器会给出警告。"}}],["$","$Lf",null,{"language":"python","code":"print(b._y)  # 2"}]]}],["$","$Ld",null,{"children":"多态"}],["$","$Le",null,{"children":"举个例子"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"多态是当一个类继承自另一个类并重写了其方法时，可以在不改变原有接口的情况下，根据对象的实际类型来调用不同的方法实现。这听起来有些复杂，我们来举一个具体的例子："}}],["$","$Lf",null,{"language":"python","code":"\n                class Unit:\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    def info(self):\n                        print(f\"name: {self.name}, hp: {self.hp}, damage: {self.damage}\")\n\n                class GroundUnit(Unit):\n                    def info(self):\n                        print(\"This is a ground unit.\")\n\n                class AirUnit(Unit):\n                    def info(self):\n                        print(\"This is an air unit.\")\n\n                def show_info(unit):\n                    unit.info()\n\n                gu1 = GroundUnit(\"gu1\", 100, 20)\n                au1 = AirUnit(\"au1\", 100, 20)\n                show_info(gu1)  # This is a ground unit.\n                show_info(au1)  # This is an air unit.\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这个例子中，<code class=\"x-inline-highlight\">show_info</code>函数接受一个<code class=\"x-inline-highlight\">Unit</code>类型的参数，但是我们传入的是其子类<code class=\"x-inline-highlight\">GroundUnit</code>和<code class=\"x-inline-highlight\">AirUnit</code>类型的实例。子类重写了父类的<code class=\"x-inline-highlight\">info</code>方法，相当于共用了父类的接口，但是子类又通过继承重写了接口，从而实现了不同的功能。"}}],["$","$Le",null,{"children":"通过抽象类实现多态"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<span class=\"x-inline-strong\">抽象类</span>是指包含<span class=\"x-inline-strong\">抽象方法</span>的类；抽象类只能被继承，不能被实例化。<br/> 抽象方法是指只有声明，没有实现的方法，它存在的意义是让子类重写这个方法。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上面的例子中，如果我们将<code class=\"x-inline-highlight\">Unit</code>类的<code class=\"x-inline-highlight\">info</code>方法定义为："}}],["$","$Lf",null,{"language":"python","highlightLines":"8-9","code":"\n                class Unit:\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    # 这是一个抽象方法，子类必须重写这个方法，否则在调用时会报错\n                    def info(self):\n                        raise NotImplementedError(\"Subclasses must implement abstract method.\")\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这时子类如果没有重写<code class=\"x-inline-highlight\">info</code>方法，就会继承父类中的方法，在调用的时候就会报错。"}}],["$","$Lf",null,{"language":"python","code":"\n                class UnitWithoutInfo(Unit):\n                    pass\n\n                u = UnitWithoutInfo(\"u\", 100, 20)\n                u.info()  # NotImplementedError: Subclasses must implement abstract method.\n                "}],["$","$Le",null,{"children":"Python中的abc模块"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"Python的<code class=\"x-inline-highlight\">abc</code>模块中定义了<span class=\"x-inline-strong\">抽象基类</span><code class=\"x-inline-highlight\">ABC (Abstract Base Classes)</code>，可以强制其子类必须实现某些方法。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上面的例子使用<code class=\"x-inline-highlight\">abc</code>模块可以改写为："}}],["$","$Lf",null,{"language":"python","highlightLines":"1,3,9-11","code":"\n                from abc import ABC, abstractmethod\n\n                class Unit(ABC):\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    @abstractmethod\n                    def info(self):\n                        pass\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这时子类如果没有重写<code class=\"x-inline-highlight\">info</code>方法，在实例化时就会报错！"}}],["$","$Lf",null,{"language":"python","code":"\n                class UnitWithoutInfo(Unit):\n                    pass\n\n                # 在实例化时就会报错\n                u = UnitWithoutInfo(\"u\", 100, 20)  # TypeError: Can't instantiate abstract class UnitWithoutInfo with abstract method info\n                "}],["$","$Ld",null,{"children":"三大方法"}],["$","$Le",null,{"children":"类方法"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"类方法用修饰器<code class=\"x-inline-highlight\">@classmethod</code>定义，传入的第一个参数是类本身而不是实例，通常命名为<code class=\"x-inline-highlight\">cls</code>。通过它可以访问到类属性。"}}],["$","$Lf",null,{"language":"python","highlightLines":"9-12","code":"\n                class Unit:\n                    utype = \"unit\"\n\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    @classmethod\n                    def show_type(cls):\n                        # 可以访问到类属性\n                        print(f\"This is a {cls.utype}.\")\n\n                u1 = Unit(\"u1\", 100, 20)\n                u1.show_type()  # This is a unit.\n                "}],["$","$L10",null,{"children":"类方法的应用：自动计算实例数"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"假如我们希望每创建一个类时，都可以自动计数当前类的实例数量。这个功能可以由类方法实现。"}}],["$","$Lf",null,{"language":"python","highlightLines":"9","code":"\n                class Unit:\n                    type = \"unit\"\n                    __unit_num = 0  # 声明为私有类属性\n\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n                        self.add_unit_num()\n\n                    @classmethod\n                    def add_unit_num(cls):\n                        cls.__unit_num += 1\n\n                    @classmethod\n                    def get_unit_num(cls):\n                        return cls.__unit_num\n\n                u1 = Unit(\"u1\", 100, 20)\n                u2 = Unit(\"u2\", 200, 10)\n                print(u1.get_unit_num())  # 2\n                print(u2.get_unit_num())  # 2\n\n                u3 = Unit(\"u3\", 300, 30)\n                print(u3.get_unit_num())  # 3\n                print(Unit.get_unit_num())  # 3\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们在<code class=\"x-inline-highlight\">__init__</code>方法中调用一次类方法<code class=\"x-inline-highlight\">add_unit_num()</code>，就可以把总实例数统计到类属性<code class=\"x-inline-highlight\">__unit_num</code>中。"}}],["$","$Le",null,{"children":"静态方法"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"静态方法用修饰器<code class=\"x-inline-highlight\">@staticmethod</code>定义。静态方法不能访问类属性，也不能访问实例属性。静态方法可以在类的命名空间内定义一些功能性代码，通常用于实现一些与类相关的工具函数。"}}],["$","$Lf",null,{"language":"python","highlightLines":"9-11","code":"\n                class Unit:\n                    type = \"unit\"\n\n                    def __init__(self, name, hp, damage):\n                        self.name = name\n                        self.hp = hp\n                        self.damage = damage\n\n                    @staticmethod\n                    def calc_hp_after_attack(hp, damage):  # 没有隐式的第一参数\n                        return hp - damage\n\n                u1 = Unit(\"u1\", 100, 20)\n                u2 = Unit(\"u2\", 200, 10)\n                print(u1.calc_hp_after_attack(u1.hp, u2.damage))  # 90\n                "}],["$","$Le",null,{"children":"属性方法"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"属性方法以方法的形式定义，但是可以像属性一样进行访问，其作用是支持对属性的灵活操作。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"属性方法相当于允许更细致的设置一个属性的<span class=\"x-inline-strong\">访问</span>、<span class=\"x-inline-strong\">更改</span>、<span class=\"x-inline-strong\">删除</span>操作，具体的做法是：实现属性的<code class=\"x-inline-highlight\">getter</code>、<code class=\"x-inline-highlight\">setter</code>、<code class=\"x-inline-highlight\">deleter</code>方法。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"假设我们有这样的需求：定义一个<code class=\"x-inline-highlight\">Circle</code>类，它具有直径<code class=\"x-inline-highlight\">diameter</code>和半径<code class=\"x-inline-highlight\">radius</code>两个属性。我们希望修改其中一个属性时，另外一个属性也随之变化。也就是："}}],["$","$Lf",null,{"language":"python","code":"\n                circle = Circle(5)\n                print(circle.radius)  # 5\n                print(circle.diameter)  # 10\n\n                circle.diameter = 14\n                print(circle.radius)  # 7.0\n\n                circle.radius = 12\n                print(circle.diameter)  # 24\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"用此前的知识似乎无法实现这样的功能，但属性方法可以解决："}}],["$","$Lf",null,{"language":"python","code":"\n                class Circle:\n                    def __init__(self, radius):\n                        self.__radius = radius\n                        self.__diameter = 2 * radius\n\n                    # 属性的getter方法\n                    @property\n                    def radius(self):\n                        return self.__radius\n\n                    # 属性的setter方法\n                    @radius.setter\n                    def radius(self, value):\n                        self.__radius = value\n                        self.__diameter = value * 2\n\n                    @property\n                    def diameter(self):\n                        return self.__diameter\n\n                    @diameter.setter\n                    def diameter(self, value):\n                        self.__diameter = value\n                        self.__radius = value * 0.5\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"将访问、修改属性的操作定义为函数，就允许了我们除了获取、修改变量本身之外，还可以做一些其他的手脚。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上面的例子没有体现属性的<code class=\"x-inline-highlight\">deleter</code>方法。它的一般实现可以是："}}],["$","$Lf",null,{"language":"python","code":"\n                class Circle:\n                    ...\n\n                    # 属性的deleter方法\n                    @radius.deleter\n                    def radius(self):\n                        print(\"delete radius\")\n                        del self.__radius\n\n                    @diameter.deleter\n                    def diameter(self):\n                        print(\"delete diameter\")\n                        del self.__diameter\n\n                del circle.diameter  # delete diameter\n                # print(circle.diameter)  # AttributeError: 'Circle' object has no attribute '_Circle__diameter'\n                "}],["$","$Ld",null,{"children":"反射"}],["$","$Le",null,{"children":"Python中的反射"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在计算机科学中<span class=\"x-inline-strong\">反射</span><code class=\"x-inline-highlight\">(reflection)</code>是指计算机程序在运行时可以检查、访问、和修改它本身状态或行为的一种能力。表现在Python面向对象编程中有四个内置函数：<code class=\"x-inline-highlight\">getattr()</code>、<code class=\"x-inline-highlight\">setattr()</code>、<code class=\"x-inline-highlight\">hasattr()</code>和<code class=\"x-inline-highlight\">delattr()</code>，可以通过字符串的形式操作对象的属性和方法。"}}],["$","$Lf",null,{"language":"python","code":"\n                class A:\n                    def __init__(self, x, y, z):\n                        self.x = x\n                        self.y = y\n                        self.z = z\n\n                    def info_x(self):\n                        print(f\"x: {self.x}\")\n\n                    def info_y(self):\n                        print(f\"y: {self.y}\")\n\n                    def info_z(self):\n                        print(f\"z: {self.z}\")\n\n                a = A(10, 20, 30)\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">hasattr()</code>函数用于判断对象是否包含对应的属性或方法："}}],["$","$Lf",null,{"language":"python","code":"\n                print(hasattr(a, \"x\"))  # True\n                print(hasattr(a, \"info_x\"))  # True\n                print(hasattr(a, \"info_w\"))  # False\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">getattr()</code>函数用于获取对象的属性或方法："}}],["$","$Lf",null,{"language":"python","code":"\n                print(getattr(a, \"x\"))  # 10\n                info_x = getattr(a, \"info_x\")\n                info_x()  # x: 10\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">setattr()</code>函数用于设置对象的属性或方法："}}],["$","$Lf",null,{"language":"python","code":"\n                setattr(a, \"x\", 100)\n                print(getattr(a, \"x\"))  # 100\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">delattr()</code>函数用于删除对象的属性或方法："}}],["$","$Lf",null,{"language":"python","code":"\n                delattr(a, \"y\")\n                print(getattr(a, \"y\"))  # AttributeError: 'A' object has no attribute 'y'\n                "}],["$","$Le",null,{"children":"反射的应用"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"假如我们现在想创建一个类<code class=\"x-inline-highlight\">A2Z</code>，它具有<code class=\"x-inline-highlight\">a</code>-<code class=\"x-inline-highlight\">z</code><code class=\"x-inline-highlight\">26</code>个属性与<code class=\"x-inline-highlight\">info_a()</code>到<code class=\"x-inline-highlight\">info_z()</code><code class=\"x-inline-highlight\">26</code>个方法，手动创建这些属性和方法是非常繁琐的。这时我们可以利用反射来动态的创建它们："}}],["$","$Lf",null,{"language":"python","highlightLines":"10,16","code":"\n                a_to_z = \"abcdefghijklmnopqrstuvwxyz\"\n\n                class A2Z:\n                    pass\n\n                a2z = A2Z()\n\n                for ch in a_to_z:\n                    # 动态的创建属性\n                    setattr(a2z, ch, ord(ch) - ord('a') + 1)\n\n                    # 动态的创建方法\n                    def info_ch():\n                        print(f\"{ch}: {getattr(a2z, ch)}\")\n\n                    setattr(a2z, f\"info_{ch}\", info_ch)\n\n                print(a2z.d)  # 4\n                a2z.info_z()  # z: 26\n                "}],["$","$Ld",null,{"children":"魔术方法"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"魔术方法通常以双下划线包围，用于实现类的特殊行为。下面以一个<code class=\"x-inline-highlight\">Vector3d</code>类为例，介绍一些常用的魔术方法。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    def __init__(self, x, y, z):\n                        self.x = x\n                        self.y = y\n                        self.z = z\n\n                v1 = Vector3d(3, 4, 5)\n                v2 = Vector3d(1, 2, 3)\n                "}],["$","$Le",null,{"children":"__len__"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">len(obj)</code>时调用。<code class=\"x-inline-highlight\">__len__</code>方法的返回值只能是整数。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    ...\n\n                    def __len__(self):\n                        return 3\n\n                print(len(v1))  # 3\n                "}],["$","$Le",null,{"children":"__repr__和__str__"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">__repr__</code>方法的返回值应该是一个<span class=\"x-inline-strong\">可以用来重新创建对象</span>的字符串。<br/> <code class=\"x-inline-highlight\">__str__</code>方法在<code class=\"x-inline-highlight\">str(obj)</code>时调用，应当返回实例格式良好、可读性强的字符串表示。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在<code class=\"x-inline-highlight\">print(obj)</code>时会优先使用<code class=\"x-inline-highlight\">__str__</code>方法的返回值，如果没有定义<code class=\"x-inline-highlight\">__str__</code>方法，则会使用<code class=\"x-inline-highlight\">__repr__</code>方法。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    ...\n\n                    def __repr__(self):\n                    return f\"Vector3d({self.x}, {self.y}, {self.z})\"\n\n                    def __str__(self):\n                        return f\"({self.x}, {self.y}, {self.z})\"\n\n                print(str(v1))  # (3, 4, 5)\n                print(repr(v1))  # Vector3d(3, 4, 5)\n                # 会优先调用__str__方法\n                print(v1)  # (3, 4, 5)\n                "}],["$","$Le",null,{"children":"__call__"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">__call__</code>方法使得实例可以像函数一样被调用。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这个例子中我们约定，调用<code class=\"x-inline-highlight\">obj(x, y, z)</code>时设置向量的<code class=\"x-inline-highlight\">x</code>，<code class=\"x-inline-highlight\">y</code>，<code class=\"x-inline-highlight\">z</code>分量。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    ...\n\n                    def __call__(self, x, y, z):\n                        self.x = x\n                        self.y = y\n                        self.z = z\n\n                v2(2, -2, 1)\n                print(v2)  # (2, -2, 1)\n                "}],["$","$Le",null,{"children":"运算符重载"}],["$","p",null,{"className":"x-p no-margin-bottom","dangerouslySetInnerHTML":{"__html":"我们为<code class=\"x-inline-highlight\">Vector3d</code>类定义加法、减法、乘法操作。这个例子中我们约定，加减法就是普通的按元素加减，而乘法满足："}}],["$","$L12",null,{"children":"`obj*常数`时返回缩放后的向量"}],["$","$L12",null,{"children":"`obj1*obj2`时返回点乘数值"}],["$","$Lf",null,{"language":"python","code":"$13"}],["$","$Le",null,{"children":"反运算（右侧运算）"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"如果只有上述运算符重载，下面的代码会报错："}}],["$","$Lf",null,{"language":"python","code":"print(2 * v1)  # TypeError: unsupported operand type(s) for *: 'int' and 'Vector3d'"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这是因为整数类型的乘法不适用。解决这个问题需要定义<code class=\"x-inline-highlight\">Vector3d</code>类的右侧乘法<code class=\"x-inline-highlight\">__rmul__</code>："}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    ...\n\n                    def __rmul__(self, other):\n                        return self.__mul__(other)\n\n                print(2 * v1)  # (6, 8, 10)\n                "}],["$","$Le",null,{"children":"__getitem__和__setitem__"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">__getitem__</code>在取<code class=\"x-inline-highlight\">obj[key]</code>时调用，这个例子中我们约定<code class=\"x-inline-highlight\">obj[key]</code>返回向量第<code class=\"x-inline-highlight\">i</code>个分量；"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">__setitem__</code>在设置<code class=\"x-inline-highlight\">obj[key]=value</code>时调用，这个例子中我们约定<code class=\"x-inline-highlight\">obj[key]=value</code>设置向量第<code class=\"x-inline-highlight\">i</code>个分量。"}}],["$","$Lf",null,{"language":"python","code":"\n                class Vector3d:\n                    ...\n\n                    def __getitem__(self, key):\n                    if key == 0:\n                        return self.x\n                    elif key == 1:\n                        return self.y\n                    elif key == 2:\n                        return self.z\n                    else:\n                        raise IndexError(f\"index out of range: {key}\")\n\n                    def __setitem__(self, key, value):\n                        if key == 0:\n                            self.x = value\n                        elif key == 1:\n                            self.y = value\n                        elif key == 2:\n                            self.z = value\n                        else:\n                            raise IndexError(f\"index out of range: {key}\")\n\n                print(v1[0], v1[1], v1[2])  # 18 -24 15\n                v1[0] = 2\n                print(v1)  # (2, -24, 15)\n                "}]],null],"segment":"__PAGE__"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f70c26425a044d6b.css","precedence":"next","crossOrigin":""}]]}],"segment":"object-oriented-programming-python"},"styles":[]}],"segment":"24a"},"styles":[]}],"params":{}}],null],"segment":"(blogs)"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c84b60895b980f14.css","precedence":"next","crossOrigin":""}]]}]]}]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Create Next App"}],["$","meta","2",{"name":"description","content":"Generated by create next app"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
b:null
