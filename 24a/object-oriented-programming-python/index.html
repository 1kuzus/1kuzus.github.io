<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/8ac0b0e7f508d966.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/c84b60895b980f14.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/f70c26425a044d6b.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-09f8a7b6b4931605.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-317889f780d115a2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-d5046572d4bcdf16.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-cfdfd0e1c1afc4e3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/app/layout-e12e822557cc964c.js" async=""></script><script src="/_next/static/chunks/176-6509553bec92a789.js" async=""></script><script src="/_next/static/chunks/app/(blogs)/layout-75f88dfdcbd0ba18.js" async=""></script><script src="/_next/static/chunks/d3ac728e-1e5d8b71e3d43fec.js" async=""></script><script src="/_next/static/chunks/202-7b9f876bcb1bf7b4.js" async=""></script><script src="/_next/static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div id="header" class=""><div id="header-left-wrapper"><div id="header-logo-bg"><svg viewBox="0 0 1560 1560" width="36px" height="36px" xmlns="http://www.w3.org/2000/svg"><g fill-rule="evenodd"><path d="M644 97h272.529L1189 780H916.471z" fill="#00A8C4"></path><path d="M98 97h272.84L780 1120.73 1189.162 97H1462L916.438 1462H643.562z" fill="#30303C"></path><path d="M98 1462L643.3 97H916L370.7 1462z" fill="#00F8FF"></path></g></svg></div><div id="header-archive"><h3 id="header-archive-text">归档</h3><div class="header-archive-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div></div><div id="header-right-wrapper"><div id="header-theme-bg"><svg viewBox="0 0 1024 1024" width="20px" height="20px" xmlns="http://www.w3.org/2000/svg"><path fill="#FCFCFC" d="M524.8 938.667h-4.267a439.893 439.893 0 01-313.173-134.4 446.293 446.293 0 01-11.093-597.334A432.213 432.213 0 01366.933 90.027a42.667 42.667 0 0145.227 9.386 42.667 42.667 0 0110.24 42.667 358.4 358.4 0 0082.773 375.893 361.387 361.387 0 00376.747 82.774 42.667 42.667 0 0154.187 55.04 433.493 433.493 0 01-99.84 154.88 438.613 438.613 0 01-311.467 128z"></path></svg></div><a href="https://github.com/1kuzus/1kuzus.github.io" target="_blank" rel="noreferrer"><div id="header-github-bg"><svg viewBox="0 0 1024 1024" width="36px" height="36px" xmlns="http://www.w3.org/2000/svg"><path d="M411.306667 831.146667c3.413333-5.12 6.826667-10.24 6.826666-11.946667v-69.973333c-105.813333 22.186667-128-44.373333-128-44.373334-17.066667-44.373333-42.666667-56.32-42.666666-56.32-34.133333-23.893333 3.413333-23.893333 3.413333-23.893333 37.546667 3.413333 58.026667 39.253333 58.026667 39.253333 34.133333 58.026667 88.746667 40.96 110.933333 32.426667 3.413333-23.893333 13.653333-40.96 23.893333-51.2-85.333333-10.24-174.08-42.666667-174.08-187.733333 0-40.96 15.36-75.093333 39.253334-102.4-3.413333-10.24-17.066667-47.786667 3.413333-100.693334 0 0 32.426667-10.24 104.106667 39.253334 30.72-8.533333 63.146667-11.946667 95.573333-11.946667 32.426667 0 64.853333 5.12 95.573333 11.946667 73.386667-49.493333 104.106667-39.253333 104.106667-39.253334 20.48 52.906667 8.533333 90.453333 3.413333 100.693334 23.893333 27.306667 39.253333 59.733333 39.253334 102.4 0 145.066667-88.746667 177.493333-174.08 187.733333 13.653333 11.946667 25.6 34.133333 25.6 69.973333v104.106667c0 3.413333 1.706667 6.826667 6.826666 11.946667 5.12 6.826667 3.413333 18.773333-3.413333 23.893333-3.413333 1.706667-6.826667 3.413333-10.24 3.413333h-174.08c-10.24 0-17.066667-6.826667-17.066667-17.066666 0-5.12 1.706667-8.533333 3.413334-10.24z" fill="#FCFCFC"></path></svg></div></a></div></div><div id="blog-layout"><div id="main"><h1 class="x-title"></h1><p class="x-p">本文对面向对象的基本理论（为什么要有类、什么是属性、什么是方法等）不多做解释，重点在Python中的编程实现。</p><h2 class="x-h1">基本操作</h2><h3 class="x-h2">定义一个类</h3><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 48px, var(--bg-transparent-golden) 48px 168px, transparent 168px)"><code class="lang-python">class Unit:
    # 初始化方法/构造函数
    def __init__(self, name, hp, damage):
        # 实例属性
        self.name = name
        self.hp = hp
        self.damage = damage

    # 实例方法
    def sayhi(self):
        print(f&quot;hi, I&#x27;m {self.name}&quot;)

u1 = Unit(&quot;u1&quot;, 100, 20)
u2 = Unit(&quot;u2&quot;, 200, 10)

u1.sayhi()  # Hi, I&#x27;m u1
print(u1.hp)  # 100
print(u1.damage)  # 20
</code></pre></div><p class="x-p">上面的代码定义了一个<code class="x-inline-highlight">Unit</code>类，这个例子中暂且理解为一个游戏中的作战单位，每个单位具有名字<code class="x-inline-highlight">name</code>、生命值<code class="x-inline-highlight">hp</code>、攻击力<code class="x-inline-highlight">damage</code>这些属性。</p><p class="x-p"><code class="x-inline-highlight">__init__</code>方法称作类的<span class="x-inline-strong">初始化方法</span>/<span class="x-inline-strong">构造函数</span>，实例本身会作为函数的第一个参数<code class="x-inline-highlight">self</code>被传入。从这个角度理解，实际上<code class="x-inline-highlight">__init__</code>方法是将传入的参数“绑定”到新创建的实例上。</p><h3 class="x-h2">类属性和实例属性</h3><p class="x-p">我们在类下直接定义了一个属性<code class="x-inline-highlight">utype</code>，它是一个<code class="x-inline-highlight">类属性</code>；与之对应的是<code class="x-inline-highlight">__init__</code>方法为实例创建的属性，我们称之为<code class="x-inline-highlight">实例属性</code>。</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 48px, var(--bg-transparent-golden) 48px 72px, transparent 72px)"><code class="lang-python">class Unit:
    # 类属性，占用同一块地址
    utype = &quot;unit&quot;

    def __init__(self, name, hp, damage):
        # 实例属性，独属于每个实例
        self.name = name
        self.hp = hp
        self.damage = damage

    def sayhi(self):
        print(&quot;hi, I&#x27;m %s&quot; % self.name)

u1 = Unit(&quot;u1&quot;, 100, 20)
u2 = Unit(&quot;u2&quot;, 200, 10)
</code></pre></div><p class="x-p">访问实例属性时，把它们当作普通变量就好了；实例属性也可以在<code class="x-inline-highlight">__init__</code>方法之外动态的添加。</p><div class="x-codeblock"><pre><code class="lang-python">print(u1.hp)  # 100
print(u1.damage)  # 20
u1.level = 1
print(u1.level)  # 1
</code></pre></div><p class="x-p">类属性可以在类上取得，也可以在实例上取得。类属性共享内存地址。</p><div class="x-codeblock"><pre><code class="lang-python">print(Unit.utype, u1.utype, u2.utype)  # unit unit unit
print(id(Unit.utype))  # 2197356757808
print(id(u1.utype))    # 2197356757808
print(id(u2.utype))    # 2197356757808
</code></pre></div><p class="x-p">由于共享内存地址，因此修改类属性具有全局性：</p><div class="x-codeblock"><pre><code class="lang-python">Unit.utype = &quot;spell&quot;
print(Unit.utype, u1.utype, u2.utype)  # spell spell spell
</code></pre></div><div class="x-highlightblock highlight-background-golden"><h4 class="x-h3">注意</h4><div class="x-codeblock"><pre><code class="lang-python">u1.utype = &quot;hero&quot;
print(Unit.utype, u1.utype, u2.utype)  # spell hero spell
</code></pre></div><p class="x-p">如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例属性。上面的例子相当于给<code class="x-inline-highlight">u1</code>添加了一个与类属性同名实例属性，<code class="x-inline-highlight">u1.utype</code>访问到的不是类属性。</p><p class="x-p">要想访问<code class="x-inline-highlight">u1</code>的类属性，可以通过<code class="x-inline-highlight">__class__</code>访问：</p><div class="x-codeblock"><pre><code class="lang-python">print(u1.__class__.utype)  # spell</code></pre></div></div><h2 class="x-h1">继承</h2><h3 class="x-h2">实现一个子类</h3><p class="x-p">我们还是定义一个<code class="x-inline-highlight">Unit</code>类，并实现两个方法：<code class="x-inline-highlight">info</code>用于输出自身基本信息，<code class="x-inline-highlight">attack</code>模拟攻击另一个单位。</p><div class="x-codeblock"><pre><code class="lang-python">class Unit:
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    def info(self):
        print(f&quot;name: {self.name}, hp: {self.hp}, damage: {self.damage}&quot;)

    def attack(self, unit):
        unit.hp -= self.damage
        print(f&quot;{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}&quot;)
</code></pre></div><p class="x-p">现在我们希望实现一个<code class="x-inline-highlight">GroundUnit</code>类，表示地面单位，并且地面单位具有特有的伤害加成，用属性<code class="x-inline-highlight">buff</code>定义。显然，会有大量的逻辑与<code class="x-inline-highlight">Unit</code>类是重复的。这时可以通过继承来实现：</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 48px, var(--bg-transparent-golden) 48px 72px, transparent 72px)"><code class="lang-python">class GroundUnit(Unit):
    def __init__(self, name, hp, damage, buff):
        super().__init__(name, hp, damage)
        # 子类新增的实例属性
        self.buff = buff

    # 重写父类方法
    def attack(self, unit):
        unit.hp -= self.damage * (1 + self.buff)
        print(f&quot;{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}&quot;)

gu1 = GroundUnit(&quot;gu1&quot;, 100, 20, 0.2)
gu2 = GroundUnit(&quot;gu2&quot;, 200, 10, 0.2)

gu2.info()  # name: gu2, hp: 200, damage: 10
gu1.attack(gu2)  # gu1 attacks gu2, gu2.hp = 176.0
gu2.info()  # name: gu2, hp: 176.0, damage: 10
</code></pre></div><p class="x-p">定义类时，用<code class="x-inline-highlight">class 子类(父类):</code>表示继承。如果子类有自己的构造函数，会覆盖父类的构造函数；否则会继承父类的构造函数。</p><p class="x-p">代码中<code class="x-inline-highlight">super()</code>函数可以找到父类，高亮的代码等价于<code class="x-inline-highlight">Unit.__init__(self, name, hp, damage)</code>。</p><p class="x-p">如果子类需要对父类的方法进行重写，只需要在子类下定义同名方法，然后重写逻辑。其他父类的方法会被继承到子类中，例如这个例子中的<code class="x-inline-highlight">info()</code>。</p><h3 class="x-h2">isinstance函数</h3><p class="x-p"><code class="x-inline-highlight">isinstance(实例,类)</code>可以判断一个实例是否属于给定的类。<span class="x-inline-strong">子类的实例同时也是父类的实例</span>。</p><div class="x-codeblock"><pre><code class="lang-python">u1 = Unit(&quot;u1&quot;, 100, 20)
gu1 = GroundUnit(&quot;gu1&quot;, 100, 20, 0.2)

print(isinstance(u1, Unit))         # True
print(isinstance(u1, GroundUnit))   # False
print(isinstance(gu1, Unit))        # True
print(isinstance(gu1, GroundUnit))  # True
</code></pre></div><h3 class="x-h2">多继承</h3><p class="x-p">假设我们的游戏复杂起来，引入了稀有度系统，每个单位有一个所属的稀有度，例如普通、稀有、史诗、传奇等等。以史诗级为例，假设对于这些不同稀有度的单位有着其他独特的机制，以至于我们不得不新创建一个<code class="x-inline-highlight">EpicRarity</code>类：</p><div class="x-codeblock"><pre><code class="lang-python">class EpicRarity:
    def __init__(self, level):
        self.level = level

    def info(self):
        print(f&quot;This is a lv.{self.level} epic unit&quot;)
</code></pre></div><p class="x-p">当然，为了便于演示，我们只定义了一个<code class="x-inline-highlight">level</code>属性和<code class="x-inline-highlight">info</code>方法。</p><p class="x-p">现在，我们想实现<code class="x-inline-highlight">EpicGroundUnit</code>子类，表示史诗级地面单位。显然它需要同时继承父类<code class="x-inline-highlight">EpicRarity</code>和<code class="x-inline-highlight">GroundUnit</code>，这就是<span class="x-inline-strong">多继承</span>。</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 48px, var(--bg-transparent-golden) 48px 96px, transparent 96px)"><code class="lang-python">class EpicGroundUnit(EpicRarity, GroundUnit):
    def __init__(self, name, hp, damage, buff, level):
        GroundUnit.__init__(self, name, hp, damage, buff)
        EpicRarity.__init__(self, level)

egu1 = EpicGroundUnit(&quot;egu1&quot;, 100, 20, 0.2, 1)

egu1.info()  # This is a lv.1 epic unit
</code></pre></div><p class="x-p">在构造函数中我们需要分别对父类进行初始化。</p><p class="x-p">注意到两个父类都实现了<code class="x-inline-highlight">info</code>方法并且没有被子类重写。调用之后我们发现，子类继承的是<code class="x-inline-highlight">EpicRarity</code>的<code class="x-inline-highlight">info</code>方法。如果代码改写为：</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 0px, var(--bg-transparent-golden) 0px 24px, transparent 24px)"><code class="lang-python">class EpicGroundUnit(GroundUnit, EpicRarity):
    def __init__(self, name, hp, damage, buff, level):
        GroundUnit.__init__(self, name, hp, damage, buff)
        EpicRarity.__init__(self, level)

egu1 = EpicGroundUnit(&quot;egu1&quot;, 100, 20, 0.2, 1)

egu1.info()  # name: egu1, hp: 100, damage: 20
</code></pre></div><p class="x-p">就会发现，调换父类的顺序后，现在子类继承的是<code class="x-inline-highlight">GroundUnit</code>的<code class="x-inline-highlight">info</code>方法。这就引出了下一节的内容：<span class="x-inline-strong">方法解析顺序</span>。</p><h3 class="x-h2">方法解析顺序MRO</h3><p class="x-p">对于多继承情况下的同名方法，如何从父类中找应该优先使用哪个父类的方法就叫<span class="x-inline-strong">方法解析顺序</span><code class="x-inline-highlight">(Method Resolution Order, MRO)</code>。 Python采用<a href="https://zh.wikipedia.org/zh-cn/C3%E7%BA%BF%E6%80%A7%E5%8C%96" target="_blank" rel="noreferrer" class="x-inline-link">C3线性化</a>算法来计算线性化列表，保证继承顺序列表中每个类只出现一次。</p><div class="x-codeblock"><pre><code class="lang-python">class A:
    def test(self):
        print(&#x27;A&#x27;)

class B:
    def test(self):
        print(&#x27;B&#x27;)

class C(A, B):
    pass

class D(C, B):
    pass

obj = D()
obj.test()  # A
</code></pre></div><p class="x-p">上述代码描述了一个如下图所示的复杂继承关系：</p><div class="x-image-wrapper x-image-invert"><img alt="img" loading="lazy" width="505" height="374" decoding="async" data-nimg="1" style="color:transparent;width:300px" src="/_next/static/media/mro.39176437.jpg"/></div><p class="x-p">可以通过<code class="x-inline-highlight">mro()</code>函数得到类的方法解析顺序：</p><div class="x-codeblock"><pre><code class="lang-python"># 注意是类名，不是实例名
print(D.mro())  # [&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]
</code></pre></div><p class="x-p">输出的列表中，从左到右的顺序为查找方法的顺序。上述例子中，<code class="x-inline-highlight">D</code>和<code class="x-inline-highlight">C</code>类都没有定义<code class="x-inline-highlight">test</code>方法，因此顺次使用了<code class="x-inline-highlight">A</code>类的<code class="x-inline-highlight">test</code>方法。</p><div class="x-highlightblock highlight-background-golden"><h4 class="x-h3">注意</h4><p class="x-p">MRO顺序不是简单的深度优先或广度优先！</p></div><h2 class="x-h1">封装</h2><p class="x-p">在前面<code class="x-inline-highlight">Unit</code>类的例子中，我们可以通过直接访问<code class="x-inline-highlight">u1.hp</code>修改其值，这样并不安全（这岂不是像外挂一样）！<span class="x-inline-strong">封装</span>的目的是为了保护数据，不让外部直接访问和修改。在Python中，约定通过在属性名称前加两个下划线<code class="x-inline-highlight">__</code>来将属性私有化。这种命名约定会使Python解释器修改变量名为<code class="x-inline-highlight">_类名__属性名</code>的形式，使其在类外部变得难以访问。</p><h3 class="x-h2">将实例属性私有化</h3><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 96px, var(--bg-transparent-golden) 96px 144px, transparent 144px)"><code class="lang-python">class Unit:
    def __init__(self, name, hp, damage):
        self.name = name
        # 私有属性
        self.__hp = hp
        self.__damage = damage

    def attack(self, unit):
        unit.__hp -= self.__damage
        print(f&quot;{self.name} attacks {unit.name}, {unit.name}.__hp = {unit.__hp}&quot;)

    # 通过公有方法访问私有属性
    def get_hp(self):
        return self.__hp
</code></pre></div><p class="x-p">在定义私有属性后，对外开放一个公有方法<code class="x-inline-highlight">get_hp</code>，通过这个公有方法可以间接的访问到<code class="x-inline-highlight">__hp</code>属性。这样相当于让此属性对外部“只读”。</p><div class="x-codeblock"><pre><code class="lang-python">u1 = Unit(&quot;u1&quot;, 100, 20)
print(u1.get_hp())  # 100
print(u1.__hp)  # AttributeError: &#x27;Unit&#x27; object has no attribute &#x27;__hp&#x27;
</code></pre></div><p class="x-p">通过<code class="x-inline-highlight">_类名__属性名</code>的形式可以强制访问私有属性：</p><div class="x-codeblock"><pre><code class="lang-python">print(u1._Unit__hp)  # 100</code></pre></div><div class="x-highlightblock highlight-background-golden"><h4 class="x-h3">注意</h4><p class="x-p">在类外绑定的双下划线变量是公有的。</p><div class="x-codeblock"><pre><code class="lang-python">u1.__var = 1
print(u1.__var)  # 1
</code></pre></div></div><h3 class="x-h2">类比于C++</h3><p class="x-p no-margin-bottom">C++中的封装有三种：<code class="x-inline-highlight">public</code>、<code class="x-inline-highlight">protected</code>、<code class="x-inline-highlight">private</code>；Python中没有这些关键字，但是可以通过属性名命名约定来实现。</p><div class="x-uli"><div class="x-uli-marker"><div class="x-uli-marker-dot"></div></div><div class="x-uli-content-wrapper"><p class="x-p"><code class="x-inline-highlight">public</code>：公有变量，可以在<span class="x-inline-strong">类的内部和外部</span>访问，正常命名即可。</p></div></div><div class="x-uli"><div class="x-uli-marker"><div class="x-uli-marker-dot"></div></div><div class="x-uli-content-wrapper"><p class="x-p"><code class="x-inline-highlight">protected</code>：保护变量，只能在<span class="x-inline-strong">类内和子类</span>访问，属性名前加单下划线<code class="x-inline-highlight">_</code>。这只是一种命名约定，实际上是可以访问的。</p></div></div><div class="x-uli"><div class="x-uli-marker"><div class="x-uli-marker-dot"></div></div><div class="x-uli-content-wrapper"><p class="x-p"><code class="x-inline-highlight">private</code>：私有变量，只能在<span class="x-inline-strong">类的内部</span>访问，属性名前加双下划线<code class="x-inline-highlight">__</code>，这样会使Python解释器修改变量名为<code class="x-inline-highlight">_类名__属性名</code>的形式。</p></div></div><div class="x-codeblock"><pre><code class="lang-python">class A:
    def __init__(self, x, y, z):
        # 公有变量
        self.x = x
        # 保护变量
        self._y = y
        # 私有变量
        self.__z = z

class B(A):
    def __init__(self, x, y, z):
        super().__init__(x, y, z)

    def info_x(self):
        print(f&quot;x: {self.x}&quot;)

    def info_y(self):
        print(f&quot;y: {self._y}&quot;)

    def info_z(self):
        print(f&quot;z: {self.__z}&quot;)

b = B(1, 2, 3)
b.info_x()  # x: 1
b.info_y()  # y: 2
b.info_z()  # AttributeError: &#x27;B&#x27; object has no attribute &#x27;_B__z&#x27;. Did you mean: &#x27;_A__z&#x27;?
</code></pre></div><div class="x-highlightblock highlight-background-golden"><h4 class="x-h3">注意</h4><p class="x-p">C++中的<code class="x-inline-highlight">protected</code>关键字是一种严格的访问控制机制，而Python中的单下划线变量只是一种命名约定，不具有强制性，实际上是可以访问的。只不过有时违反了这样的约定时，有些代码编辑器会给出警告。</p><div class="x-codeblock"><pre><code class="lang-python">print(b._y)  # 2</code></pre></div></div><h2 class="x-h1">多态</h2><h3 class="x-h2">举个例子</h3><p class="x-p">多态是当一个类继承自另一个类并重写了其方法时，可以在不改变原有接口的情况下，根据对象的实际类型来调用不同的方法实现。这听起来有些复杂，我们来举一个具体的例子：</p><div class="x-codeblock"><pre><code class="lang-python">class Unit:
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    def info(self):
        print(f&quot;name: {self.name}, hp: {self.hp}, damage: {self.damage}&quot;)

class GroundUnit(Unit):
    def info(self):
        print(&quot;This is a ground unit.&quot;)

class AirUnit(Unit):
    def info(self):
        print(&quot;This is an air unit.&quot;)

def show_info(unit):
    unit.info()

gu1 = GroundUnit(&quot;gu1&quot;, 100, 20)
au1 = AirUnit(&quot;au1&quot;, 100, 20)
show_info(gu1)  # This is a ground unit.
show_info(au1)  # This is an air unit.
</code></pre></div><p class="x-p">这个例子中，<code class="x-inline-highlight">show_info</code>函数接受一个<code class="x-inline-highlight">Unit</code>类型的参数，但是我们传入的是其子类<code class="x-inline-highlight">GroundUnit</code>和<code class="x-inline-highlight">AirUnit</code>类型的实例。子类重写了父类的<code class="x-inline-highlight">info</code>方法，相当于共用了父类的接口，但是子类又通过继承重写了接口，从而实现了不同的功能。</p><h3 class="x-h2">通过抽象类实现多态</h3><p class="x-p"><span class="x-inline-strong">抽象类</span>是指包含<span class="x-inline-strong">抽象方法</span>的类；抽象类只能被继承，不能被实例化。<br/> 抽象方法是指只有声明，没有实现的方法，它存在的意义是让子类重写这个方法。</p><p class="x-p">上面的例子中，如果我们将<code class="x-inline-highlight">Unit</code>类的<code class="x-inline-highlight">info</code>方法定义为：</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 168px, var(--bg-transparent-golden) 168px 216px, transparent 216px)"><code class="lang-python">class Unit:
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    # 这是一个抽象方法，子类必须重写这个方法，否则在调用时会报错
    def info(self):
        raise NotImplementedError(&quot;Subclasses must implement abstract method.&quot;)
</code></pre></div><p class="x-p">这时子类如果没有重写<code class="x-inline-highlight">info</code>方法，就会继承父类中的方法，在调用的时候就会报错。</p><div class="x-codeblock"><pre><code class="lang-python">class UnitWithoutInfo(Unit):
    pass

u = UnitWithoutInfo(&quot;u&quot;, 100, 20)
u.info()  # NotImplementedError: Subclasses must implement abstract method.
</code></pre></div><h3 class="x-h2">Python中的abc模块</h3><p class="x-p">Python的<code class="x-inline-highlight">abc</code>模块中定义了<span class="x-inline-strong">抽象基类</span><code class="x-inline-highlight">ABC (Abstract Base Classes)</code>，可以强制其子类必须实现某些方法。</p><p class="x-p">上面的例子使用<code class="x-inline-highlight">abc</code>模块可以改写为：</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 0px, var(--bg-transparent-golden) 0px 24px, transparent 24px, transparent 48px, var(--bg-transparent-golden) 48px 72px, transparent 72px, transparent 192px, var(--bg-transparent-golden) 192px 264px, transparent 264px)"><code class="lang-python">from abc import ABC, abstractmethod

class Unit(ABC):
    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    @abstractmethod
    def info(self):
        pass
</code></pre></div><p class="x-p">这时子类如果没有重写<code class="x-inline-highlight">info</code>方法，在实例化时就会报错！</p><div class="x-codeblock"><pre><code class="lang-python">class UnitWithoutInfo(Unit):
    pass

# 在实例化时就会报错
u = UnitWithoutInfo(&quot;u&quot;, 100, 20)  # TypeError: Can&#x27;t instantiate abstract class UnitWithoutInfo with abstract method info
</code></pre></div><h2 class="x-h1">三大方法</h2><h3 class="x-h2">类方法</h3><p class="x-p">类方法用修饰器<code class="x-inline-highlight">@classmethod</code>定义，传入的第一个参数是类本身而不是实例，通常命名为<code class="x-inline-highlight">cls</code>。通过它可以访问到类属性。</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 192px, var(--bg-transparent-golden) 192px 288px, transparent 288px)"><code class="lang-python">class Unit:
    utype = &quot;unit&quot;

    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    @classmethod
    def show_type(cls):
        # 可以访问到类属性
        print(f&quot;This is a {cls.utype}.&quot;)

u1 = Unit(&quot;u1&quot;, 100, 20)
u1.show_type()  # This is a unit.
</code></pre></div><h4 class="x-h3">类方法的应用：自动计算实例数</h4><p class="x-p">假如我们希望每创建一个类时，都可以自动计数当前类的实例数量。这个功能可以由类方法实现。</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 192px, var(--bg-transparent-golden) 192px 216px, transparent 216px)"><code class="lang-python">class Unit:
    type = &quot;unit&quot;
    __unit_num = 0  # 声明为私有类属性

    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage
        self.add_unit_num()

    @classmethod
    def add_unit_num(cls):
        cls.__unit_num += 1

    @classmethod
    def get_unit_num(cls):
        return cls.__unit_num

u1 = Unit(&quot;u1&quot;, 100, 20)
u2 = Unit(&quot;u2&quot;, 200, 10)
print(u1.get_unit_num())  # 2
print(u2.get_unit_num())  # 2

u3 = Unit(&quot;u3&quot;, 300, 30)
print(u3.get_unit_num())  # 3
print(Unit.get_unit_num())  # 3
</code></pre></div><p class="x-p">我们在<code class="x-inline-highlight">__init__</code>方法中调用一次类方法<code class="x-inline-highlight">add_unit_num()</code>，就可以把总实例数统计到类属性<code class="x-inline-highlight">__unit_num</code>中。</p><h3 class="x-h2">静态方法</h3><p class="x-p">静态方法用修饰器<code class="x-inline-highlight">@staticmethod</code>定义。静态方法不能访问类属性，也不能访问实例属性。静态方法可以在类的命名空间内定义一些功能性代码，通常用于实现一些与类相关的工具函数。</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 192px, var(--bg-transparent-golden) 192px 264px, transparent 264px)"><code class="lang-python">class Unit:
    type = &quot;unit&quot;

    def __init__(self, name, hp, damage):
        self.name = name
        self.hp = hp
        self.damage = damage

    @staticmethod
    def calc_hp_after_attack(hp, damage):  # 没有隐式的第一参数
        return hp - damage

u1 = Unit(&quot;u1&quot;, 100, 20)
u2 = Unit(&quot;u2&quot;, 200, 10)
print(u1.calc_hp_after_attack(u1.hp, u2.damage))  # 90
</code></pre></div><h3 class="x-h2">属性方法</h3><p class="x-p">属性方法以方法的形式定义，但是可以像属性一样进行访问，其作用是支持对属性的灵活操作。</p><p class="x-p">属性方法相当于允许更细致的设置一个属性的<span class="x-inline-strong">访问</span>、<span class="x-inline-strong">更改</span>、<span class="x-inline-strong">删除</span>操作，具体的做法是：实现属性的<code class="x-inline-highlight">getter</code>、<code class="x-inline-highlight">setter</code>、<code class="x-inline-highlight">deleter</code>方法。</p><p class="x-p">假设我们有这样的需求：定义一个<code class="x-inline-highlight">Circle</code>类，它具有直径<code class="x-inline-highlight">diameter</code>和半径<code class="x-inline-highlight">radius</code>两个属性。我们希望修改其中一个属性时，另外一个属性也随之变化。也就是：</p><div class="x-codeblock"><pre><code class="lang-python">circle = Circle(5)
print(circle.radius)  # 5
print(circle.diameter)  # 10

circle.diameter = 14
print(circle.radius)  # 7.0

circle.radius = 12
print(circle.diameter)  # 24
</code></pre></div><p class="x-p">用此前的知识似乎无法实现这样的功能，但属性方法可以解决：</p><div class="x-codeblock"><pre><code class="lang-python">class Circle:
    def __init__(self, radius):
        self.__radius = radius
        self.__diameter = 2 * radius

    # 属性的getter方法
    @property
    def radius(self):
        return self.__radius

    # 属性的setter方法
    @radius.setter
    def radius(self, value):
        self.__radius = value
        self.__diameter = value * 2

    @property
    def diameter(self):
        return self.__diameter

    @diameter.setter
    def diameter(self, value):
        self.__diameter = value
        self.__radius = value * 0.5
</code></pre></div><p class="x-p">将访问、修改属性的操作定义为函数，就允许了我们除了获取、修改变量本身之外，还可以做一些其他的手脚。</p><p class="x-p">上面的例子没有体现属性的<code class="x-inline-highlight">deleter</code>方法。它的一般实现可以是：</p><div class="x-codeblock"><pre><code class="lang-python">class Circle:
    ...

    # 属性的deleter方法
    @radius.deleter
    def radius(self):
        print(&quot;delete radius&quot;)
        del self.__radius

    @diameter.deleter
    def diameter(self):
        print(&quot;delete diameter&quot;)
        del self.__diameter

del circle.diameter  # delete diameter
# print(circle.diameter)  # AttributeError: &#x27;Circle&#x27; object has no attribute &#x27;_Circle__diameter&#x27;
</code></pre></div><h2 class="x-h1">反射</h2><h3 class="x-h2">Python中的反射</h3><p class="x-p">在计算机科学中<span class="x-inline-strong">反射</span><code class="x-inline-highlight">(reflection)</code>是指计算机程序在运行时可以检查、访问、和修改它本身状态或行为的一种能力。表现在Python面向对象编程中有四个内置函数：<code class="x-inline-highlight">getattr()</code>、<code class="x-inline-highlight">setattr()</code>、<code class="x-inline-highlight">hasattr()</code>和<code class="x-inline-highlight">delattr()</code>，可以通过字符串的形式操作对象的属性和方法。</p><div class="x-codeblock"><pre><code class="lang-python">class A:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def info_x(self):
        print(f&quot;x: {self.x}&quot;)

    def info_y(self):
        print(f&quot;y: {self.y}&quot;)

    def info_z(self):
        print(f&quot;z: {self.z}&quot;)

a = A(10, 20, 30)
</code></pre></div><p class="x-p"><code class="x-inline-highlight">hasattr()</code>函数用于判断对象是否包含对应的属性或方法：</p><div class="x-codeblock"><pre><code class="lang-python">print(hasattr(a, &quot;x&quot;))  # True
print(hasattr(a, &quot;info_x&quot;))  # True
print(hasattr(a, &quot;info_w&quot;))  # False
</code></pre></div><p class="x-p"><code class="x-inline-highlight">getattr()</code>函数用于获取对象的属性或方法：</p><div class="x-codeblock"><pre><code class="lang-python">print(getattr(a, &quot;x&quot;))  # 10
info_x = getattr(a, &quot;info_x&quot;)
info_x()  # x: 10
</code></pre></div><p class="x-p"><code class="x-inline-highlight">setattr()</code>函数用于设置对象的属性或方法：</p><div class="x-codeblock"><pre><code class="lang-python">setattr(a, &quot;x&quot;, 100)
print(getattr(a, &quot;x&quot;))  # 100
</code></pre></div><p class="x-p"><code class="x-inline-highlight">delattr()</code>函数用于删除对象的属性或方法：</p><div class="x-codeblock"><pre><code class="lang-python">delattr(a, &quot;y&quot;)
print(getattr(a, &quot;y&quot;))  # AttributeError: &#x27;A&#x27; object has no attribute &#x27;y&#x27;
</code></pre></div><h3 class="x-h2">反射的应用</h3><p class="x-p">假如我们现在想创建一个类<code class="x-inline-highlight">A2Z</code>，它具有<code class="x-inline-highlight">a</code>-<code class="x-inline-highlight">z</code><code class="x-inline-highlight">26</code>个属性与<code class="x-inline-highlight">info_a()</code>到<code class="x-inline-highlight">info_z()</code><code class="x-inline-highlight">26</code>个方法，手动创建这些属性和方法是非常繁琐的。这时我们可以利用反射来动态的创建它们：</p><div class="x-codeblock"><pre style="background:linear-gradient(180deg, transparent 216px, var(--bg-transparent-golden) 216px 240px, transparent 240px, transparent 360px, var(--bg-transparent-golden) 360px 384px, transparent 384px)"><code class="lang-python">a_to_z = &quot;abcdefghijklmnopqrstuvwxyz&quot;

class A2Z:
    pass

a2z = A2Z()

for ch in a_to_z:
    # 动态的创建属性
    setattr(a2z, ch, ord(ch) - ord(&#x27;a&#x27;) + 1)

    # 动态的创建方法
    def info_ch():
        print(f&quot;{ch}: {getattr(a2z, ch)}&quot;)

    setattr(a2z, f&quot;info_{ch}&quot;, info_ch)

print(a2z.d)  # 4
a2z.info_z()  # z: 26
</code></pre></div><h2 class="x-h1">魔术方法</h2><p class="x-p">魔术方法通常以双下划线包围，用于实现类的特殊行为。下面以一个<code class="x-inline-highlight">Vector3d</code>类为例，介绍一些常用的魔术方法。</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

v1 = Vector3d(3, 4, 5)
v2 = Vector3d(1, 2, 3)
</code></pre></div><h3 class="x-h2">__len__</h3><p class="x-p"><code class="x-inline-highlight">len(obj)</code>时调用。<code class="x-inline-highlight">__len__</code>方法的返回值只能是整数。</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    def __len__(self):
        return 3

print(len(v1))  # 3
</code></pre></div><h3 class="x-h2">__repr__和__str__</h3><p class="x-p"><code class="x-inline-highlight">__repr__</code>方法的返回值应该是一个<span class="x-inline-strong">可以用来重新创建对象</span>的字符串。<br/> <code class="x-inline-highlight">__str__</code>方法在<code class="x-inline-highlight">str(obj)</code>时调用，应当返回实例格式良好、可读性强的字符串表示。</p><p class="x-p">在<code class="x-inline-highlight">print(obj)</code>时会优先使用<code class="x-inline-highlight">__str__</code>方法的返回值，如果没有定义<code class="x-inline-highlight">__str__</code>方法，则会使用<code class="x-inline-highlight">__repr__</code>方法。</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    def __repr__(self):
    return f&quot;Vector3d({self.x}, {self.y}, {self.z})&quot;

    def __str__(self):
        return f&quot;({self.x}, {self.y}, {self.z})&quot;

print(str(v1))  # (3, 4, 5)
print(repr(v1))  # Vector3d(3, 4, 5)
# 会优先调用__str__方法
print(v1)  # (3, 4, 5)
</code></pre></div><h3 class="x-h2">__call__</h3><p class="x-p"><code class="x-inline-highlight">__call__</code>方法使得实例可以像函数一样被调用。</p><p class="x-p">这个例子中我们约定，调用<code class="x-inline-highlight">obj(x, y, z)</code>时设置向量的<code class="x-inline-highlight">x</code>，<code class="x-inline-highlight">y</code>，<code class="x-inline-highlight">z</code>分量。</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    def __call__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

v2(2, -2, 1)
print(v2)  # (2, -2, 1)
</code></pre></div><h3 class="x-h2">运算符重载</h3><p class="x-p no-margin-bottom">我们为<code class="x-inline-highlight">Vector3d</code>类定义加法、减法、乘法操作。这个例子中我们约定，加减法就是普通的按元素加减，而乘法满足：</p><div class="x-uli"><div class="x-uli-marker"><div class="x-uli-marker-dot"></div></div><div class="x-uli-content-wrapper"><p class="x-p"><code class="x-inline-highlight">obj*常数</code>时返回缩放后的向量</p></div></div><div class="x-uli"><div class="x-uli-marker"><div class="x-uli-marker-dot"></div></div><div class="x-uli-content-wrapper"><p class="x-p"><code class="x-inline-highlight">obj1*obj2</code>时返回点乘数值</p></div></div><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    # 重载加号运算符，obj1+obj2时调用
    def __add__(self, other):
        return Vector3d(self.x + other.x, self.y + other.y, self.z + other.z)

    # 重载减号运算符，obj1-obj2时调用
    def __sub__(self, other):
        return Vector3d(self.x - other.x, self.y - other.y, self.z - other.z)

    # 重载乘号运算符
    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return Vector3d(self.x * other, self.y * other, self.z * other)
        else:
            return self.x * other.x + self.y * other.y + self.z * other.z

print(v1)  # (3, 4, 5)
print(v2)  # (2, -2, 1)
print(v1 + v2)  # (5, 2, 6)
print(v1 - v2)  # (1, 6, 4)
print(v1 * v2)  # 3
print(v1 * 2)  # (6, 8, 10)
</code></pre></div><h3 class="x-h2">反运算（右侧运算）</h3><p class="x-p">如果只有上述运算符重载，下面的代码会报错：</p><div class="x-codeblock"><pre><code class="lang-python">print(2 * v1)  # TypeError: unsupported operand type(s) for *: &#x27;int&#x27; and &#x27;Vector3d&#x27;</code></pre></div><p class="x-p">这是因为整数类型的乘法不适用。解决这个问题需要定义<code class="x-inline-highlight">Vector3d</code>类的右侧乘法<code class="x-inline-highlight">__rmul__</code>：</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    def __rmul__(self, other):
        return self.__mul__(other)

print(2 * v1)  # (6, 8, 10)
</code></pre></div><h3 class="x-h2">__getitem__和__setitem__</h3><p class="x-p"><code class="x-inline-highlight">__getitem__</code>在取<code class="x-inline-highlight">obj[key]</code>时调用，这个例子中我们约定<code class="x-inline-highlight">obj[key]</code>返回向量第<code class="x-inline-highlight">i</code>个分量；</p><p class="x-p"><code class="x-inline-highlight">__setitem__</code>在设置<code class="x-inline-highlight">obj[key]=value</code>时调用，这个例子中我们约定<code class="x-inline-highlight">obj[key]=value</code>设置向量第<code class="x-inline-highlight">i</code>个分量。</p><div class="x-codeblock"><pre><code class="lang-python">class Vector3d:
    ...

    def __getitem__(self, key):
    if key == 0:
        return self.x
    elif key == 1:
        return self.y
    elif key == 2:
        return self.z
    else:
        raise IndexError(f&quot;index out of range: {key}&quot;)

    def __setitem__(self, key, value):
        if key == 0:
            self.x = value
        elif key == 1:
            self.y = value
        elif key == 2:
            self.z = value
        else:
            raise IndexError(f&quot;index out of range: {key}&quot;)

print(v1[0], v1[1], v1[2])  # 18 -24 15
v1[0] = 2
print(v1)  # (2, -24, 15)
</code></pre></div></div><div id="sidebar"><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">网络杂识 (4)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/database-3nf/"><span class="sidebar-list-title">数据库设计三大范式</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/github-linguist-vendored/"><span class="sidebar-list-title">不统计Github仓库某个目录下的语言</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/deepl-shortcut-setting/"><span class="sidebar-list-title">解决：DeepL该快捷键已被使用</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/git-merge-allow-unrelated-histories/"><span class="sidebar-list-title">记录：使用--allow-unrelated-histories</span></a></li></ul></div></div><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">深度学习 (5)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/longtime/papers/"><span class="sidebar-list-title">论文速记</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/r2plus1d/"><span class="sidebar-list-title">行为识别R(2+1)D网络</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/object-detection-map/"><span class="sidebar-list-title">目标检测评价指标mAP</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/learn-rnn-lstm/"><span class="sidebar-list-title">学习RNN和LSTM</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/reproduce-nerf-rpn/"><span class="sidebar-list-title">记录：复现NeRF-RPN代码</span></a></li></ul></div></div><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">Python学习 (2)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/torch-numpy-topk/"><span class="sidebar-list-title">在pytorch和numpy中取top-k值和索引</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/object-oriented-programming-python/"><span class="sidebar-list-title">Python面向对象编程</span></a></li></ul></div></div><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">前端与JavaScript (2)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23c/js-array/"><span class="sidebar-list-title">JavaScript数组常用方法</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/css-auto-height-transition/"><span class="sidebar-list-title">CSS实现auto高度的过渡动画</span></a></li></ul></div></div><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">课程 (10)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23c/pattern-recognition-1/"><span class="sidebar-list-title">【模式识别】统计决策方法</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23c/pattern-recognition-2/"><span class="sidebar-list-title">【模式识别】参数估计</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23c/pattern-recognition-3/"><span class="sidebar-list-title">【模式识别】非参数估计</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/pattern-recognition-4/"><span class="sidebar-list-title">【模式识别】线性学习器与线性分类器</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/23d/protocols/"><span class="sidebar-list-title">【计算机网络】协议总结</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/machine-learning-exercises/"><span class="sidebar-list-title">【机器学习】习题</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/games101-01-transformation/"><span class="sidebar-list-title">【GAMES101】Transformation</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/games101-02-rasterization/"><span class="sidebar-list-title">【GAMES101】Rasterization</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/games101-03-shading/"><span class="sidebar-list-title">【GAMES101】Shading</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/24a/games101-04-geometry/"><span class="sidebar-list-title">【GAMES101】Geometry</span></a></li></ul></div></div><div class="sidebar-list show-list"><div class="sidebar-list-head"><h3 class="sidebar-list-category">其他 (2)</h3><div class="sidebar-list-category-rightarrow"><svg viewBox="0 0 1024 1024" width="16px" height="16px" xmlns="http://www.w3.org/2000/svg"><path d="M761.056 532.128c.512-.992 1.344-1.824 1.792-2.848 8.8-18.304 5.92-40.704-9.664-55.424L399.936 139.744c-19.264-18.208-49.632-17.344-67.872 1.888-18.208 19.264-17.376 49.632 1.888 67.872l316.96 299.84L335.2 813.632c-19.072 18.4-19.648 48.768-1.248 67.872 9.408 9.792 21.984 14.688 34.56 14.688 12 0 24-4.48 33.312-13.44l350.048-337.376c.672-.672.928-1.6 1.6-2.304.512-.48 1.056-.832 1.568-1.344 2.72-2.848 4.16-6.336 6.016-9.6z" fill="#50505c"></path></svg></div></div><div class="sidebar-list-ul-wrapper"><ul class="sidebar-list-ul"><li class="sidebar-list-li"><a class="sidebar-list-link" href="/longtime/demo/"><span class="sidebar-list-title">示例</span></a></li><li class="sidebar-list-li"><a class="sidebar-list-link" href="/longtime/updates/"><span class="sidebar-list-title">更新日志</span></a></li></ul></div></div></div><div id="sidebar-mask"></div></div><script src="/_next/static/chunks/webpack-09f8a7b6b4931605.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/8ac0b0e7f508d966.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/c84b60895b980f14.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/f70c26425a044d6b.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[3728,[],\"\"]\n7:I[9928,[],\"\"]\n8:I[9226,[\"185\",\"static/chunks/app/layout-e12e822557cc964c.js\"],\"GlobalProvider\"]\n9:I[9330,[\"185\",\"static/chunks/app/layout-e12e822557cc964c.js\"],\"\"]\na:I[6954,[],\"\"]\nb:I[7264,[],\"\"]\nc:I[5285,[\"176\",\"static/chunks/176-6509553bec92a789.js\",\"135\",\"static/chunks/app/(blogs)/layout-75f88dfdcbd0ba18.js\"],\"\"]\ne:I[4484,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-pyth"])</script><script>self.__next_f.push([1,"on/page-091cbc7e9a2a0d7f.js\"],\"Title\"]\nf:I[4484,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"H1\"]\n10:I[4484,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"H2\"]\n11:I[9708,[\"954\",\"static/chunks/d3ac728e-1e5d8b7"])</script><script>self.__next_f.push([1,"1e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"\"]\n12:I[4484,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"H3\"]\n13:I[8411,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(bl"])</script><script>self.__next_f.push([1,"ogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"\"]\n14:I[8275,[\"954\",\"static/chunks/d3ac728e-1e5d8b71e3d43fec.js\",\"202\",\"static/chunks/202-7b9f876bcb1bf7b4.js\",\"481\",\"static/chunks/app/(blogs)/24a/object-oriented-programming-python/page-091cbc7e9a2a0d7f.js\"],\"Uli\"]\n15:T448,"])</script><script>self.__next_f.push([1,"\n                class Vector3d:\n                    ...\n\n                    # 重载加号运算符，obj1+obj2时调用\n                    def __add__(self, other):\n                        return Vector3d(self.x + other.x, self.y + other.y, self.z + other.z)\n\n                    # 重载减号运算符，obj1-obj2时调用\n                    def __sub__(self, other):\n                        return Vector3d(self.x - other.x, self.y - other.y, self.z - other.z)\n\n                    # 重载乘号运算符\n                    def __mul__(self, other):\n                        if isinstance(other, (int, float)):\n                            return Vector3d(self.x * other, self.y * other, self.z * other)\n                        else:\n                            return self.x * other.x + self.y * other.y + self.z * other.z\n\n                print(v1)  # (3, 4, 5)\n                print(v2)  # (2, -2, 1)\n                print(v1 + v2)  # (5, 2, 6)\n                print(v1 - v2)  # (1, 6, 4)\n                print(v1 * v2)  # 3\n                print(v1 * 2)  # (6, 8, 10)\n                "])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/8ac0b0e7f508d966.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"aCGhGRfB6AbKUEnvQWAtS\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/24a/object-oriented-programming-python/\",\"initialTree\":[\"\",{\"children\":[\"(blogs)\",{\"children\":[\"24a\",{\"children\":[\"object-oriented-programming-python\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L6\"],\"globalErrorComponent\":\"$7\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L8\",null,{\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[null,[\"$\",\"$Lc\",null,{\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(blogs)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(blogs)\",\"children\",\"24a\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(blogs)\",\"children\",\"24a\",\"children\",\"object-oriented-programming-python\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Ld\",[[\"$\",\"$Le\",null,{\"children\":\"$undefined\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"本文对面向对象的基本理论（为什么要有类、什么是属性、什么是方法等）不多做解释，重点在Python中的编程实现。\"}}],[\"$\",\"$Lf\",null,{\"children\":\"基本操作\"}],[\"$\",\"$L10\",null,{\"children\":\"定义一个类\"}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"3-7\",\"code\":\"\\n                class Unit:\\n                    # 初始化方法/构造函数\\n                    def __init__(self, name, hp, damage):\\n                        # 实例属性\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    # 实例方法\\n                    def sayhi(self):\\n                        print(f\\\"hi, I'm {self.name}\\\")\\n\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                u2 = Unit(\\\"u2\\\", 200, 10)\\n\\n                u1.sayhi()  # Hi, I'm u1\\n                print(u1.hp)  # 100\\n                print(u1.damage)  # 20\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"上面的代码定义了一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类，这个例子中暂且理解为一个游戏中的作战单位，每个单位具有名字\u003ccode class=\\\"x-inline-highlight\\\"\u003ename\u003c/code\u003e、生命值\u003ccode class=\\\"x-inline-highlight\\\"\u003ehp\u003c/code\u003e、攻击力\u003ccode class=\\\"x-inline-highlight\\\"\u003edamage\u003c/code\u003e这些属性。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003e__init__\u003c/code\u003e方法称作类的\u003cspan class=\\\"x-inline-strong\\\"\u003e初始化方法\u003c/span\u003e/\u003cspan class=\\\"x-inline-strong\\\"\u003e构造函数\u003c/span\u003e，实例本身会作为函数的第一个参数\u003ccode class=\\\"x-inline-highlight\\\"\u003eself\u003c/code\u003e被传入。从这个角度理解，实际上\u003ccode class=\\\"x-inline-highlight\\\"\u003e__init__\u003c/code\u003e方法是将传入的参数“绑定”到新创建的实例上。\"}}],[\"$\",\"$L10\",null,{\"children\":\"类属性和实例属性\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"我们在类下直接定义了一个属性\u003ccode class=\\\"x-inline-highlight\\\"\u003eutype\u003c/code\u003e，它是一个\u003ccode class=\\\"x-inline-highlight\\\"\u003e类属性\u003c/code\u003e；与之对应的是\u003ccode class=\\\"x-inline-highlight\\\"\u003e__init__\u003c/code\u003e方法为实例创建的属性，我们称之为\u003ccode class=\\\"x-inline-highlight\\\"\u003e实例属性\u003c/code\u003e。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"3\",\"code\":\"\\n                class Unit:\\n                    # 类属性，占用同一块地址\\n                    utype = \\\"unit\\\"\\n\\n                    def __init__(self, name, hp, damage):\\n                        # 实例属性，独属于每个实例\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    def sayhi(self):\\n                        print(\\\"hi, I'm %s\\\" % self.name)\\n\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                u2 = Unit(\\\"u2\\\", 200, 10)\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"访问实例属性时，把它们当作普通变量就好了；实例属性也可以在\u003ccode class=\\\"x-inline-highlight\\\"\u003e__init__\u003c/code\u003e方法之外动态的添加。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                print(u1.hp)  # 100\\n                print(u1.damage)  # 20\\n                u1.level = 1\\n                print(u1.level)  # 1\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"类属性可以在类上取得，也可以在实例上取得。类属性共享内存地址。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                print(Unit.utype, u1.utype, u2.utype)  # unit unit unit\\n                print(id(Unit.utype))  # 2197356757808\\n                print(id(u1.utype))    # 2197356757808\\n                print(id(u2.utype))    # 2197356757808\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"由于共享内存地址，因此修改类属性具有全局性：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                Unit.utype = \\\"spell\\\"\\n                print(Unit.utype, u1.utype, u2.utype)  # spell spell spell\\n                \"}],[\"$\",\"div\",null,{\"className\":\"x-highlightblock highlight-background-golden\",\"children\":[[\"$\",\"$L12\",null,{\"children\":\"注意\"}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                    u1.utype = \\\"hero\\\"\\n                    print(Unit.utype, u1.utype, u2.utype)  # spell hero spell\\n                    \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例属性。上面的例子相当于给\u003ccode class=\\\"x-inline-highlight\\\"\u003eu1\u003c/code\u003e添加了一个与类属性同名实例属性，\u003ccode class=\\\"x-inline-highlight\\\"\u003eu1.utype\u003c/code\u003e访问到的不是类属性。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"要想访问\u003ccode class=\\\"x-inline-highlight\\\"\u003eu1\u003c/code\u003e的类属性，可以通过\u003ccode class=\\\"x-inline-highlight\\\"\u003e__class__\u003c/code\u003e访问：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"print(u1.__class__.utype)  # spell\"}]]}],[\"$\",\"$Lf\",null,{\"children\":\"继承\"}],[\"$\",\"$L10\",null,{\"children\":\"实现一个子类\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"我们还是定义一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类，并实现两个方法：\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e用于输出自身基本信息，\u003ccode class=\\\"x-inline-highlight\\\"\u003eattack\u003c/code\u003e模拟攻击另一个单位。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Unit:\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    def info(self):\\n                        print(f\\\"name: {self.name}, hp: {self.hp}, damage: {self.damage}\\\")\\n\\n                    def attack(self, unit):\\n                        unit.hp -= self.damage\\n                        print(f\\\"{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}\\\")\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"现在我们希望实现一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eGroundUnit\u003c/code\u003e类，表示地面单位，并且地面单位具有特有的伤害加成，用属性\u003ccode class=\\\"x-inline-highlight\\\"\u003ebuff\u003c/code\u003e定义。显然，会有大量的逻辑与\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类是重复的。这时可以通过继承来实现：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"3\",\"code\":\"\\n                class GroundUnit(Unit):\\n                    def __init__(self, name, hp, damage, buff):\\n                        super().__init__(name, hp, damage)\\n                        # 子类新增的实例属性\\n                        self.buff = buff\\n\\n                    # 重写父类方法\\n                    def attack(self, unit):\\n                        unit.hp -= self.damage * (1 + self.buff)\\n                        print(f\\\"{self.name} attacks {unit.name}, {unit.name}.hp = {unit.hp}\\\")\\n\\n                gu1 = GroundUnit(\\\"gu1\\\", 100, 20, 0.2)\\n                gu2 = GroundUnit(\\\"gu2\\\", 200, 10, 0.2)\\n\\n                gu2.info()  # name: gu2, hp: 200, damage: 10\\n                gu1.attack(gu2)  # gu1 attacks gu2, gu2.hp = 176.0\\n                gu2.info()  # name: gu2, hp: 176.0, damage: 10\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"定义类时，用\u003ccode class=\\\"x-inline-highlight\\\"\u003eclass 子类(父类):\u003c/code\u003e表示继承。如果子类有自己的构造函数，会覆盖父类的构造函数；否则会继承父类的构造函数。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"代码中\u003ccode class=\\\"x-inline-highlight\\\"\u003esuper()\u003c/code\u003e函数可以找到父类，高亮的代码等价于\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit.__init__(self, name, hp, damage)\u003c/code\u003e。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"如果子类需要对父类的方法进行重写，只需要在子类下定义同名方法，然后重写逻辑。其他父类的方法会被继承到子类中，例如这个例子中的\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo()\u003c/code\u003e。\"}}],[\"$\",\"$L10\",null,{\"children\":\"isinstance函数\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003eisinstance(实例,类)\u003c/code\u003e可以判断一个实例是否属于给定的类。\u003cspan class=\\\"x-inline-strong\\\"\u003e子类的实例同时也是父类的实例\u003c/span\u003e。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                gu1 = GroundUnit(\\\"gu1\\\", 100, 20, 0.2)\\n\\n                print(isinstance(u1, Unit))         # True\\n                print(isinstance(u1, GroundUnit))   # False\\n                print(isinstance(gu1, Unit))        # True\\n                print(isinstance(gu1, GroundUnit))  # True\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"多继承\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"假设我们的游戏复杂起来，引入了稀有度系统，每个单位有一个所属的稀有度，例如普通、稀有、史诗、传奇等等。以史诗级为例，假设对于这些不同稀有度的单位有着其他独特的机制，以至于我们不得不新创建一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eEpicRarity\u003c/code\u003e类：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class EpicRarity:\\n                    def __init__(self, level):\\n                        self.level = level\\n\\n                    def info(self):\\n                        print(f\\\"This is a lv.{self.level} epic unit\\\")\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"当然，为了便于演示，我们只定义了一个\u003ccode class=\\\"x-inline-highlight\\\"\u003elevel\u003c/code\u003e属性和\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"现在，我们想实现\u003ccode class=\\\"x-inline-highlight\\\"\u003eEpicGroundUnit\u003c/code\u003e子类，表示史诗级地面单位。显然它需要同时继承父类\u003ccode class=\\\"x-inline-highlight\\\"\u003eEpicRarity\u003c/code\u003e和\u003ccode class=\\\"x-inline-highlight\\\"\u003eGroundUnit\u003c/code\u003e，这就是\u003cspan class=\\\"x-inline-strong\\\"\u003e多继承\u003c/span\u003e。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"3-4\",\"code\":\"\\n                class EpicGroundUnit(EpicRarity, GroundUnit):\\n                    def __init__(self, name, hp, damage, buff, level):\\n                        GroundUnit.__init__(self, name, hp, damage, buff)\\n                        EpicRarity.__init__(self, level)\\n\\n                egu1 = EpicGroundUnit(\\\"egu1\\\", 100, 20, 0.2, 1)\\n\\n                egu1.info()  # This is a lv.1 epic unit\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在构造函数中我们需要分别对父类进行初始化。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"注意到两个父类都实现了\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法并且没有被子类重写。调用之后我们发现，子类继承的是\u003ccode class=\\\"x-inline-highlight\\\"\u003eEpicRarity\u003c/code\u003e的\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法。如果代码改写为：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"1\",\"code\":\"\\n                class EpicGroundUnit(GroundUnit, EpicRarity):\\n                    def __init__(self, name, hp, damage, buff, level):\\n                        GroundUnit.__init__(self, name, hp, damage, buff)\\n                        EpicRarity.__init__(self, level)\\n\\n                egu1 = EpicGroundUnit(\\\"egu1\\\", 100, 20, 0.2, 1)\\n\\n                egu1.info()  # name: egu1, hp: 100, damage: 20\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"就会发现，调换父类的顺序后，现在子类继承的是\u003ccode class=\\\"x-inline-highlight\\\"\u003eGroundUnit\u003c/code\u003e的\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法。这就引出了下一节的内容：\u003cspan class=\\\"x-inline-strong\\\"\u003e方法解析顺序\u003c/span\u003e。\"}}],[\"$\",\"$L10\",null,{\"children\":\"方法解析顺序MRO\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"对于多继承情况下的同名方法，如何从父类中找应该优先使用哪个父类的方法就叫\u003cspan class=\\\"x-inline-strong\\\"\u003e方法解析顺序\u003c/span\u003e\u003ccode class=\\\"x-inline-highlight\\\"\u003e(Method Resolution Order, MRO)\u003c/code\u003e。 Python采用\u003ca href=\\\"https://zh.wikipedia.org/zh-cn/C3%E7%BA%BF%E6%80%A7%E5%8C%96\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\" class=\\\"x-inline-link\\\"\u003eC3线性化\u003c/a\u003e算法来计算线性化列表，保证继承顺序列表中每个类只出现一次。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class A:\\n                    def test(self):\\n                        print('A')\\n\\n                class B:\\n                    def test(self):\\n                        print('B')\\n\\n                class C(A, B):\\n                    pass\\n\\n                class D(C, B):\\n                    pass\\n\\n                obj = D()\\n                obj.test()  # A\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"上述代码描述了一个如下图所示的复杂继承关系：\"}}],[\"$\",\"$L13\",null,{\"src\":{\"default\":{\"src\":\"/_next/static/media/mro.39176437.jpg\",\"height\":374,\"width\":505,\"blurDataURL\":\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAYACAMBIgACEQEDEQH/xAAnAAEBAAAAAAAAAAAAAAAAAAAABwEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAAr4P/xAAZEAACAwEAAAAAAAAAAAAAAAABAgARQVH/2gAIAQEAAT8AdQK4cn//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAECAQE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AH//2Q==\",\"blurWidth\":8,\"blurHeight\":6}},\"width\":\"300px\",\"invertInDarkTheme\":true}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"可以通过\u003ccode class=\\\"x-inline-highlight\\\"\u003emro()\u003c/code\u003e函数得到类的方法解析顺序：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                # 注意是类名，不是实例名\\n                print(D.mro())  # [\u003cclass '__main__.D'\u003e, \u003cclass '__main__.C'\u003e, \u003cclass '__main__.A'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass 'object'\u003e]\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"输出的列表中，从左到右的顺序为查找方法的顺序。上述例子中，\u003ccode class=\\\"x-inline-highlight\\\"\u003eD\u003c/code\u003e和\u003ccode class=\\\"x-inline-highlight\\\"\u003eC\u003c/code\u003e类都没有定义\u003ccode class=\\\"x-inline-highlight\\\"\u003etest\u003c/code\u003e方法，因此顺次使用了\u003ccode class=\\\"x-inline-highlight\\\"\u003eA\u003c/code\u003e类的\u003ccode class=\\\"x-inline-highlight\\\"\u003etest\u003c/code\u003e方法。\"}}],[\"$\",\"div\",null,{\"className\":\"x-highlightblock highlight-background-golden\",\"children\":[[\"$\",\"$L12\",null,{\"children\":\"注意\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"MRO顺序不是简单的深度优先或广度优先！\"}}]]}],[\"$\",\"$Lf\",null,{\"children\":\"封装\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在前面\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类的例子中，我们可以通过直接访问\u003ccode class=\\\"x-inline-highlight\\\"\u003eu1.hp\u003c/code\u003e修改其值，这样并不安全（这岂不是像外挂一样）！\u003cspan class=\\\"x-inline-strong\\\"\u003e封装\u003c/span\u003e的目的是为了保护数据，不让外部直接访问和修改。在Python中，约定通过在属性名称前加两个下划线\u003ccode class=\\\"x-inline-highlight\\\"\u003e__\u003c/code\u003e来将属性私有化。这种命名约定会使Python解释器修改变量名为\u003ccode class=\\\"x-inline-highlight\\\"\u003e_类名__属性名\u003c/code\u003e的形式，使其在类外部变得难以访问。\"}}],[\"$\",\"$L10\",null,{\"children\":\"将实例属性私有化\"}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"5-6\",\"code\":\"\\n                class Unit:\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        # 私有属性\\n                        self.__hp = hp\\n                        self.__damage = damage\\n\\n                    def attack(self, unit):\\n                        unit.__hp -= self.__damage\\n                        print(f\\\"{self.name} attacks {unit.name}, {unit.name}.__hp = {unit.__hp}\\\")\\n\\n                    # 通过公有方法访问私有属性\\n                    def get_hp(self):\\n                        return self.__hp\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在定义私有属性后，对外开放一个公有方法\u003ccode class=\\\"x-inline-highlight\\\"\u003eget_hp\u003c/code\u003e，通过这个公有方法可以间接的访问到\u003ccode class=\\\"x-inline-highlight\\\"\u003e__hp\u003c/code\u003e属性。这样相当于让此属性对外部“只读”。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                print(u1.get_hp())  # 100\\n                print(u1.__hp)  # AttributeError: 'Unit' object has no attribute '__hp'\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"通过\u003ccode class=\\\"x-inline-highlight\\\"\u003e_类名__属性名\u003c/code\u003e的形式可以强制访问私有属性：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"print(u1._Unit__hp)  # 100\"}],[\"$\",\"div\",null,{\"className\":\"x-highlightblock highlight-background-golden\",\"children\":[[\"$\",\"$L12\",null,{\"children\":\"注意\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在类外绑定的双下划线变量是公有的。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                    u1.__var = 1\\n                    print(u1.__var)  # 1\\n                    \"}]]}],[\"$\",\"$L10\",null,{\"children\":\"类比于C++\"}],[\"$\",\"p\",null,{\"className\":\"x-p no-margin-bottom\",\"dangerouslySetInnerHTML\":{\"__html\":\"C++中的封装有三种：\u003ccode class=\\\"x-inline-highlight\\\"\u003epublic\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003eprotected\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003eprivate\u003c/code\u003e；Python中没有这些关键字，但是可以通过属性名命名约定来实现。\"}}],[\"$\",\"$L14\",null,{\"children\":\"`public`：公有变量，可以在*类的内部和外部*访问，正常命名即可。\"}],[\"$\",\"$L14\",null,{\"children\":\"`protected`：保护变量，只能在*类内和子类*访问，属性名前加单下划线`_`。这只是一种命名约定，实际上是可以访问的。\"}],[\"$\",\"$L14\",null,{\"children\":\"`private`：私有变量，只能在*类的内部*访问，属性名前加双下划线`__`，这样会使Python解释器修改变量名为`_类名__属性名`的形式。\"}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class A:\\n                    def __init__(self, x, y, z):\\n                        # 公有变量\\n                        self.x = x\\n                        # 保护变量\\n                        self._y = y\\n                        # 私有变量\\n                        self.__z = z\\n\\n                class B(A):\\n                    def __init__(self, x, y, z):\\n                        super().__init__(x, y, z)\\n\\n                    def info_x(self):\\n                        print(f\\\"x: {self.x}\\\")\\n\\n                    def info_y(self):\\n                        print(f\\\"y: {self._y}\\\")\\n\\n                    def info_z(self):\\n                        print(f\\\"z: {self.__z}\\\")\\n\\n                b = B(1, 2, 3)\\n                b.info_x()  # x: 1\\n                b.info_y()  # y: 2\\n                b.info_z()  # AttributeError: 'B' object has no attribute '_B__z'. Did you mean: '_A__z'?\\n                \"}],[\"$\",\"div\",null,{\"className\":\"x-highlightblock highlight-background-golden\",\"children\":[[\"$\",\"$L12\",null,{\"children\":\"注意\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"C++中的\u003ccode class=\\\"x-inline-highlight\\\"\u003eprotected\u003c/code\u003e关键字是一种严格的访问控制机制，而Python中的单下划线变量只是一种命名约定，不具有强制性，实际上是可以访问的。只不过有时违反了这样的约定时，有些代码编辑器会给出警告。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"print(b._y)  # 2\"}]]}],[\"$\",\"$Lf\",null,{\"children\":\"多态\"}],[\"$\",\"$L10\",null,{\"children\":\"举个例子\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"多态是当一个类继承自另一个类并重写了其方法时，可以在不改变原有接口的情况下，根据对象的实际类型来调用不同的方法实现。这听起来有些复杂，我们来举一个具体的例子：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Unit:\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    def info(self):\\n                        print(f\\\"name: {self.name}, hp: {self.hp}, damage: {self.damage}\\\")\\n\\n                class GroundUnit(Unit):\\n                    def info(self):\\n                        print(\\\"This is a ground unit.\\\")\\n\\n                class AirUnit(Unit):\\n                    def info(self):\\n                        print(\\\"This is an air unit.\\\")\\n\\n                def show_info(unit):\\n                    unit.info()\\n\\n                gu1 = GroundUnit(\\\"gu1\\\", 100, 20)\\n                au1 = AirUnit(\\\"au1\\\", 100, 20)\\n                show_info(gu1)  # This is a ground unit.\\n                show_info(au1)  # This is an air unit.\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"这个例子中，\u003ccode class=\\\"x-inline-highlight\\\"\u003eshow_info\u003c/code\u003e函数接受一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类型的参数，但是我们传入的是其子类\u003ccode class=\\\"x-inline-highlight\\\"\u003eGroundUnit\u003c/code\u003e和\u003ccode class=\\\"x-inline-highlight\\\"\u003eAirUnit\u003c/code\u003e类型的实例。子类重写了父类的\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法，相当于共用了父类的接口，但是子类又通过继承重写了接口，从而实现了不同的功能。\"}}],[\"$\",\"$L10\",null,{\"children\":\"通过抽象类实现多态\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cspan class=\\\"x-inline-strong\\\"\u003e抽象类\u003c/span\u003e是指包含\u003cspan class=\\\"x-inline-strong\\\"\u003e抽象方法\u003c/span\u003e的类；抽象类只能被继承，不能被实例化。\u003cbr/\u003e 抽象方法是指只有声明，没有实现的方法，它存在的意义是让子类重写这个方法。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"上面的例子中，如果我们将\u003ccode class=\\\"x-inline-highlight\\\"\u003eUnit\u003c/code\u003e类的\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法定义为：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"8-9\",\"code\":\"\\n                class Unit:\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    # 这是一个抽象方法，子类必须重写这个方法，否则在调用时会报错\\n                    def info(self):\\n                        raise NotImplementedError(\\\"Subclasses must implement abstract method.\\\")\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"这时子类如果没有重写\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法，就会继承父类中的方法，在调用的时候就会报错。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class UnitWithoutInfo(Unit):\\n                    pass\\n\\n                u = UnitWithoutInfo(\\\"u\\\", 100, 20)\\n                u.info()  # NotImplementedError: Subclasses must implement abstract method.\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"Python中的abc模块\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"Python的\u003ccode class=\\\"x-inline-highlight\\\"\u003eabc\u003c/code\u003e模块中定义了\u003cspan class=\\\"x-inline-strong\\\"\u003e抽象基类\u003c/span\u003e\u003ccode class=\\\"x-inline-highlight\\\"\u003eABC (Abstract Base Classes)\u003c/code\u003e，可以强制其子类必须实现某些方法。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"上面的例子使用\u003ccode class=\\\"x-inline-highlight\\\"\u003eabc\u003c/code\u003e模块可以改写为：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"1,3,9-11\",\"code\":\"\\n                from abc import ABC, abstractmethod\\n\\n                class Unit(ABC):\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    @abstractmethod\\n                    def info(self):\\n                        pass\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"这时子类如果没有重写\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo\u003c/code\u003e方法，在实例化时就会报错！\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class UnitWithoutInfo(Unit):\\n                    pass\\n\\n                # 在实例化时就会报错\\n                u = UnitWithoutInfo(\\\"u\\\", 100, 20)  # TypeError: Can't instantiate abstract class UnitWithoutInfo with abstract method info\\n                \"}],[\"$\",\"$Lf\",null,{\"children\":\"三大方法\"}],[\"$\",\"$L10\",null,{\"children\":\"类方法\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"类方法用修饰器\u003ccode class=\\\"x-inline-highlight\\\"\u003e@classmethod\u003c/code\u003e定义，传入的第一个参数是类本身而不是实例，通常命名为\u003ccode class=\\\"x-inline-highlight\\\"\u003ecls\u003c/code\u003e。通过它可以访问到类属性。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"9-12\",\"code\":\"\\n                class Unit:\\n                    utype = \\\"unit\\\"\\n\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    @classmethod\\n                    def show_type(cls):\\n                        # 可以访问到类属性\\n                        print(f\\\"This is a {cls.utype}.\\\")\\n\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                u1.show_type()  # This is a unit.\\n                \"}],[\"$\",\"$L12\",null,{\"children\":\"类方法的应用：自动计算实例数\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"假如我们希望每创建一个类时，都可以自动计数当前类的实例数量。这个功能可以由类方法实现。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"9\",\"code\":\"\\n                class Unit:\\n                    type = \\\"unit\\\"\\n                    __unit_num = 0  # 声明为私有类属性\\n\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n                        self.add_unit_num()\\n\\n                    @classmethod\\n                    def add_unit_num(cls):\\n                        cls.__unit_num += 1\\n\\n                    @classmethod\\n                    def get_unit_num(cls):\\n                        return cls.__unit_num\\n\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                u2 = Unit(\\\"u2\\\", 200, 10)\\n                print(u1.get_unit_num())  # 2\\n                print(u2.get_unit_num())  # 2\\n\\n                u3 = Unit(\\\"u3\\\", 300, 30)\\n                print(u3.get_unit_num())  # 3\\n                print(Unit.get_unit_num())  # 3\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"我们在\u003ccode class=\\\"x-inline-highlight\\\"\u003e__init__\u003c/code\u003e方法中调用一次类方法\u003ccode class=\\\"x-inline-highlight\\\"\u003eadd_unit_num()\u003c/code\u003e，就可以把总实例数统计到类属性\u003ccode class=\\\"x-inline-highlight\\\"\u003e__unit_num\u003c/code\u003e中。\"}}],[\"$\",\"$L10\",null,{\"children\":\"静态方法\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"静态方法用修饰器\u003ccode class=\\\"x-inline-highlight\\\"\u003e@staticmethod\u003c/code\u003e定义。静态方法不能访问类属性，也不能访问实例属性。静态方法可以在类的命名空间内定义一些功能性代码，通常用于实现一些与类相关的工具函数。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"9-11\",\"code\":\"\\n                class Unit:\\n                    type = \\\"unit\\\"\\n\\n                    def __init__(self, name, hp, damage):\\n                        self.name = name\\n                        self.hp = hp\\n                        self.damage = damage\\n\\n                    @staticmethod\\n                    def calc_hp_after_attack(hp, damage):  # 没有隐式的第一参数\\n                        return hp - damage\\n\\n                u1 = Unit(\\\"u1\\\", 100, 20)\\n                u2 = Unit(\\\"u2\\\", 200, 10)\\n                print(u1.calc_hp_after_attack(u1.hp, u2.damage))  # 90\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"属性方法\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"属性方法以方法的形式定义，但是可以像属性一样进行访问，其作用是支持对属性的灵活操作。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"属性方法相当于允许更细致的设置一个属性的\u003cspan class=\\\"x-inline-strong\\\"\u003e访问\u003c/span\u003e、\u003cspan class=\\\"x-inline-strong\\\"\u003e更改\u003c/span\u003e、\u003cspan class=\\\"x-inline-strong\\\"\u003e删除\u003c/span\u003e操作，具体的做法是：实现属性的\u003ccode class=\\\"x-inline-highlight\\\"\u003egetter\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003esetter\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003edeleter\u003c/code\u003e方法。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"假设我们有这样的需求：定义一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eCircle\u003c/code\u003e类，它具有直径\u003ccode class=\\\"x-inline-highlight\\\"\u003ediameter\u003c/code\u003e和半径\u003ccode class=\\\"x-inline-highlight\\\"\u003eradius\u003c/code\u003e两个属性。我们希望修改其中一个属性时，另外一个属性也随之变化。也就是：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                circle = Circle(5)\\n                print(circle.radius)  # 5\\n                print(circle.diameter)  # 10\\n\\n                circle.diameter = 14\\n                print(circle.radius)  # 7.0\\n\\n                circle.radius = 12\\n                print(circle.diameter)  # 24\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"用此前的知识似乎无法实现这样的功能，但属性方法可以解决：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Circle:\\n                    def __init__(self, radius):\\n                        self.__radius = radius\\n                        self.__diameter = 2 * radius\\n\\n                    # 属性的getter方法\\n                    @property\\n                    def radius(self):\\n                        return self.__radius\\n\\n                    # 属性的setter方法\\n                    @radius.setter\\n                    def radius(self, value):\\n                        self.__radius = value\\n                        self.__diameter = value * 2\\n\\n                    @property\\n                    def diameter(self):\\n                        return self.__diameter\\n\\n                    @diameter.setter\\n                    def diameter(self, value):\\n                        self.__diameter = value\\n                        self.__radius = value * 0.5\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"将访问、修改属性的操作定义为函数，就允许了我们除了获取、修改变量本身之外，还可以做一些其他的手脚。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"上面的例子没有体现属性的\u003ccode class=\\\"x-inline-highlight\\\"\u003edeleter\u003c/code\u003e方法。它的一般实现可以是：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Circle:\\n                    ...\\n\\n                    # 属性的deleter方法\\n                    @radius.deleter\\n                    def radius(self):\\n                        print(\\\"delete radius\\\")\\n                        del self.__radius\\n\\n                    @diameter.deleter\\n                    def diameter(self):\\n                        print(\\\"delete diameter\\\")\\n                        del self.__diameter\\n\\n                del circle.diameter  # delete diameter\\n                # print(circle.diameter)  # AttributeError: 'Circle' object has no attribute '_Circle__diameter'\\n                \"}],[\"$\",\"$Lf\",null,{\"children\":\"反射\"}],[\"$\",\"$L10\",null,{\"children\":\"Python中的反射\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在计算机科学中\u003cspan class=\\\"x-inline-strong\\\"\u003e反射\u003c/span\u003e\u003ccode class=\\\"x-inline-highlight\\\"\u003e(reflection)\u003c/code\u003e是指计算机程序在运行时可以检查、访问、和修改它本身状态或行为的一种能力。表现在Python面向对象编程中有四个内置函数：\u003ccode class=\\\"x-inline-highlight\\\"\u003egetattr()\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003esetattr()\u003c/code\u003e、\u003ccode class=\\\"x-inline-highlight\\\"\u003ehasattr()\u003c/code\u003e和\u003ccode class=\\\"x-inline-highlight\\\"\u003edelattr()\u003c/code\u003e，可以通过字符串的形式操作对象的属性和方法。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class A:\\n                    def __init__(self, x, y, z):\\n                        self.x = x\\n                        self.y = y\\n                        self.z = z\\n\\n                    def info_x(self):\\n                        print(f\\\"x: {self.x}\\\")\\n\\n                    def info_y(self):\\n                        print(f\\\"y: {self.y}\\\")\\n\\n                    def info_z(self):\\n                        print(f\\\"z: {self.z}\\\")\\n\\n                a = A(10, 20, 30)\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003ehasattr()\u003c/code\u003e函数用于判断对象是否包含对应的属性或方法：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                print(hasattr(a, \\\"x\\\"))  # True\\n                print(hasattr(a, \\\"info_x\\\"))  # True\\n                print(hasattr(a, \\\"info_w\\\"))  # False\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003egetattr()\u003c/code\u003e函数用于获取对象的属性或方法：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                print(getattr(a, \\\"x\\\"))  # 10\\n                info_x = getattr(a, \\\"info_x\\\")\\n                info_x()  # x: 10\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003esetattr()\u003c/code\u003e函数用于设置对象的属性或方法：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                setattr(a, \\\"x\\\", 100)\\n                print(getattr(a, \\\"x\\\"))  # 100\\n                \"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003edelattr()\u003c/code\u003e函数用于删除对象的属性或方法：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                delattr(a, \\\"y\\\")\\n                print(getattr(a, \\\"y\\\"))  # AttributeError: 'A' object has no attribute 'y'\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"反射的应用\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"假如我们现在想创建一个类\u003ccode class=\\\"x-inline-highlight\\\"\u003eA2Z\u003c/code\u003e，它具有\u003ccode class=\\\"x-inline-highlight\\\"\u003ea\u003c/code\u003e-\u003ccode class=\\\"x-inline-highlight\\\"\u003ez\u003c/code\u003e\u003ccode class=\\\"x-inline-highlight\\\"\u003e26\u003c/code\u003e个属性与\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo_a()\u003c/code\u003e到\u003ccode class=\\\"x-inline-highlight\\\"\u003einfo_z()\u003c/code\u003e\u003ccode class=\\\"x-inline-highlight\\\"\u003e26\u003c/code\u003e个方法，手动创建这些属性和方法是非常繁琐的。这时我们可以利用反射来动态的创建它们：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"highlightLines\":\"10,16\",\"code\":\"\\n                a_to_z = \\\"abcdefghijklmnopqrstuvwxyz\\\"\\n\\n                class A2Z:\\n                    pass\\n\\n                a2z = A2Z()\\n\\n                for ch in a_to_z:\\n                    # 动态的创建属性\\n                    setattr(a2z, ch, ord(ch) - ord('a') + 1)\\n\\n                    # 动态的创建方法\\n                    def info_ch():\\n                        print(f\\\"{ch}: {getattr(a2z, ch)}\\\")\\n\\n                    setattr(a2z, f\\\"info_{ch}\\\", info_ch)\\n\\n                print(a2z.d)  # 4\\n                a2z.info_z()  # z: 26\\n                \"}],[\"$\",\"$Lf\",null,{\"children\":\"魔术方法\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"魔术方法通常以双下划线包围，用于实现类的特殊行为。下面以一个\u003ccode class=\\\"x-inline-highlight\\\"\u003eVector3d\u003c/code\u003e类为例，介绍一些常用的魔术方法。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    def __init__(self, x, y, z):\\n                        self.x = x\\n                        self.y = y\\n                        self.z = z\\n\\n                v1 = Vector3d(3, 4, 5)\\n                v2 = Vector3d(1, 2, 3)\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"__len__\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003elen(obj)\u003c/code\u003e时调用。\u003ccode class=\\\"x-inline-highlight\\\"\u003e__len__\u003c/code\u003e方法的返回值只能是整数。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    ...\\n\\n                    def __len__(self):\\n                        return 3\\n\\n                print(len(v1))  # 3\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"__repr__和__str__\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003e__repr__\u003c/code\u003e方法的返回值应该是一个\u003cspan class=\\\"x-inline-strong\\\"\u003e可以用来重新创建对象\u003c/span\u003e的字符串。\u003cbr/\u003e \u003ccode class=\\\"x-inline-highlight\\\"\u003e__str__\u003c/code\u003e方法在\u003ccode class=\\\"x-inline-highlight\\\"\u003estr(obj)\u003c/code\u003e时调用，应当返回实例格式良好、可读性强的字符串表示。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"在\u003ccode class=\\\"x-inline-highlight\\\"\u003eprint(obj)\u003c/code\u003e时会优先使用\u003ccode class=\\\"x-inline-highlight\\\"\u003e__str__\u003c/code\u003e方法的返回值，如果没有定义\u003ccode class=\\\"x-inline-highlight\\\"\u003e__str__\u003c/code\u003e方法，则会使用\u003ccode class=\\\"x-inline-highlight\\\"\u003e__repr__\u003c/code\u003e方法。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    ...\\n\\n                    def __repr__(self):\\n                    return f\\\"Vector3d({self.x}, {self.y}, {self.z})\\\"\\n\\n                    def __str__(self):\\n                        return f\\\"({self.x}, {self.y}, {self.z})\\\"\\n\\n                print(str(v1))  # (3, 4, 5)\\n                print(repr(v1))  # Vector3d(3, 4, 5)\\n                # 会优先调用__str__方法\\n                print(v1)  # (3, 4, 5)\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"__call__\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003e__call__\u003c/code\u003e方法使得实例可以像函数一样被调用。\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"这个例子中我们约定，调用\u003ccode class=\\\"x-inline-highlight\\\"\u003eobj(x, y, z)\u003c/code\u003e时设置向量的\u003ccode class=\\\"x-inline-highlight\\\"\u003ex\u003c/code\u003e，\u003ccode class=\\\"x-inline-highlight\\\"\u003ey\u003c/code\u003e，\u003ccode class=\\\"x-inline-highlight\\\"\u003ez\u003c/code\u003e分量。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    ...\\n\\n                    def __call__(self, x, y, z):\\n                        self.x = x\\n                        self.y = y\\n                        self.z = z\\n\\n                v2(2, -2, 1)\\n                print(v2)  # (2, -2, 1)\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"运算符重载\"}],[\"$\",\"p\",null,{\"className\":\"x-p no-margin-bottom\",\"dangerouslySetInnerHTML\":{\"__html\":\"我们为\u003ccode class=\\\"x-inline-highlight\\\"\u003eVector3d\u003c/code\u003e类定义加法、减法、乘法操作。这个例子中我们约定，加减法就是普通的按元素加减，而乘法满足：\"}}],[\"$\",\"$L14\",null,{\"children\":\"`obj*常数`时返回缩放后的向量\"}],[\"$\",\"$L14\",null,{\"children\":\"`obj1*obj2`时返回点乘数值\"}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"$15\"}],[\"$\",\"$L10\",null,{\"children\":\"反运算（右侧运算）\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"如果只有上述运算符重载，下面的代码会报错：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"print(2 * v1)  # TypeError: unsupported operand type(s) for *: 'int' and 'Vector3d'\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"这是因为整数类型的乘法不适用。解决这个问题需要定义\u003ccode class=\\\"x-inline-highlight\\\"\u003eVector3d\u003c/code\u003e类的右侧乘法\u003ccode class=\\\"x-inline-highlight\\\"\u003e__rmul__\u003c/code\u003e：\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    ...\\n\\n                    def __rmul__(self, other):\\n                        return self.__mul__(other)\\n\\n                print(2 * v1)  # (6, 8, 10)\\n                \"}],[\"$\",\"$L10\",null,{\"children\":\"__getitem__和__setitem__\"}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003e__getitem__\u003c/code\u003e在取\u003ccode class=\\\"x-inline-highlight\\\"\u003eobj[key]\u003c/code\u003e时调用，这个例子中我们约定\u003ccode class=\\\"x-inline-highlight\\\"\u003eobj[key]\u003c/code\u003e返回向量第\u003ccode class=\\\"x-inline-highlight\\\"\u003ei\u003c/code\u003e个分量；\"}}],[\"$\",\"p\",null,{\"className\":\"x-p\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ccode class=\\\"x-inline-highlight\\\"\u003e__setitem__\u003c/code\u003e在设置\u003ccode class=\\\"x-inline-highlight\\\"\u003eobj[key]=value\u003c/code\u003e时调用，这个例子中我们约定\u003ccode class=\\\"x-inline-highlight\\\"\u003eobj[key]=value\u003c/code\u003e设置向量第\u003ccode class=\\\"x-inline-highlight\\\"\u003ei\u003c/code\u003e个分量。\"}}],[\"$\",\"$L11\",null,{\"language\":\"python\",\"code\":\"\\n                class Vector3d:\\n                    ...\\n\\n                    def __getitem__(self, key):\\n                    if key == 0:\\n                        return self.x\\n                    elif key == 1:\\n                        return self.y\\n                    elif key == 2:\\n                        return self.z\\n                    else:\\n                        raise IndexError(f\\\"index out of range: {key}\\\")\\n\\n                    def __setitem__(self, key, value):\\n                        if key == 0:\\n                            self.x = value\\n                        elif key == 1:\\n                            self.y = value\\n                        elif key == 2:\\n                            self.z = value\\n                        else:\\n                            raise IndexError(f\\\"index out of range: {key}\\\")\\n\\n                print(v1[0], v1[1], v1[2])  # 18 -24 15\\n                v1[0] = 2\\n                print(v1)  # (2, -24, 15)\\n                \"}]],null],\"segment\":\"__PAGE__\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/f70c26425a044d6b.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}],\"segment\":\"object-oriented-programming-python\"},\"styles\":[]}],\"segment\":\"24a\"},\"styles\":[]}],\"params\":{}}],null],\"segment\":\"(blogs)\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c84b60895b980f14.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}]]\nd:null\n"])</script></body></html>