1:HL["/_next/static/css/8ac0b0e7f508d966.css","style",{"crossOrigin":""}]
0:["F8tpvN5-yNKUAmwFuXero",[[["",{"children":["(blogs)",{"children":["24a",{"children":["torch-numpy-topk",{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/8ac0b0e7f508d966.css","precedence":"next","crossOrigin":""}]],"$L3"]]]]
4:HL["/_next/static/css/d1ba65e78d6f432c.css","style",{"crossOrigin":""}]
5:HL["/_next/static/css/f70c26425a044d6b.css","style",{"crossOrigin":""}]
6:I[9226,["185","static/chunks/app/layout-959d1352bec0edcb.js"],"GlobalProvider"]
7:I[9330,["185","static/chunks/app/layout-959d1352bec0edcb.js"],""]
8:I[6954,[],""]
9:I[7264,[],""]
a:I[413,["413","static/chunks/413-dc980fd24c15cede.js","160","static/chunks/app/not-found-aa1272efa852a321.js"],"Image"]
b:I[5285,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","413","static/chunks/413-dc980fd24c15cede.js","202","static/chunks/202-268c3b9a2ea32d77.js","396","static/chunks/396-150eb8004cde3d82.js","135","static/chunks/app/(blogs)/layout-39f18c96d96b8978.js"],""]
d:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","413","static/chunks/413-dc980fd24c15cede.js","202","static/chunks/202-268c3b9a2ea32d77.js","857","static/chunks/app/(blogs)/24a/torch-numpy-topk/page-b60b7ac62ca0d469.js"],"Title"]
e:I[9708,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","413","static/chunks/413-dc980fd24c15cede.js","202","static/chunks/202-268c3b9a2ea32d77.js","857","static/chunks/app/(blogs)/24a/torch-numpy-topk/page-b60b7ac62ca0d469.js"],""]
f:I[4484,["954","static/chunks/d3ac728e-1e5d8b71e3d43fec.js","413","static/chunks/413-dc980fd24c15cede.js","202","static/chunks/202-268c3b9a2ea32d77.js","857","static/chunks/app/(blogs)/24a/torch-numpy-topk/page-b60b7ac62ca0d469.js"],"H1"]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Create Next App"}],["$","meta","2",{"name":"description","content":"Generated by create next app"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
2:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L6",null,{"children":[["$","$L7",null,{}],["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":["$","div",null,{"id":"notfound","children":[["$","$La",null,{"alt":"img","width":true,"height":true,"src":"/next.svg","style":{"width":500,"height":"auto"}}],["$","div",null,{"id":"notfound-404","children":"404"}],["$","div",null,{"id":"notfound-text","children":"Page Not Found"}]]}],"notFoundStyles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/eccd2e7a1149e571.css","precedence":"next","crossOrigin":""}]],"childProp":{"current":[null,["$","$Lb",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children","24a","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","(blogs)","children","24a","children","torch-numpy-topk","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$Lc",[["$","$Ld",null,{"children":"$undefined"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们定义这样一个数组："}}],["$","$Le",null,{"language":"python","code":"\n                import numpy\n                import torch\n\n                #numpy\n                arr=numpy.array([\n                    [1,4,5,7,8],\n                    [9,1,2,8,4],\n                    [8,5,1,3,6],\n                    [3,2,4,6,5],\n                ])\n\n                #torch\n                tsr=torch.tensor(arr)\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们希望沿第<code class=\"x-inline-highlight\">1</code>维度也就是列维度取前<code class=\"x-inline-highlight\">3</code>大的数值，也就是其他维度保持不变，将列维度变为<code class=\"x-inline-highlight\">3</code>，并且保留的是前三大的元素。"}}],["$","$Lf",null,{"children":"pytorch"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"在pytorch中已经内置了<code class=\"x-inline-highlight\">topk</code>函数："}}],["$","$Le",null,{"language":"python","code":"\n                val,idx=torch.topk(tsr,k=3,dim=1)\n\n                print(val)\n                # tensor([[8, 7, 5],\n                #         [9, 8, 4],\n                #         [8, 6, 5],\n                #         [6, 5, 4]])\n\n                print(idx)\n                # tensor([[4, 3, 2],\n                #         [0, 3, 4],\n                #         [0, 4, 1],\n                #         [3, 4, 2]])\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">val</code>输出了前三大元素的值，<code class=\"x-inline-highlight\">idx</code>是索引，这已经是想要的结果了。"}}],["$","$Lf",null,{"children":"numpy"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"numpy中没有直接实现<code class=\"x-inline-highlight\">topk</code>功能的函数，需要多一些步骤："}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"首先使用<code class=\"x-inline-highlight\">numpy.argpartition</code>函数，这个函数会将下标为<code class=\"x-inline-highlight\">kth</code>的元素排列到其正确位置并返回索引，保证其左边的元素都比它小，右边的元素都比它大，但左右两侧的序列并不一定是有序的。"}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"由于<code class=\"x-inline-highlight\">numpy.argpartition</code>的排列顺序是从小到大，为了得到从大到小的索引，对输入<code class=\"x-inline-highlight\">arr</code>取了负值。"}}],["$","$Le",null,{"language":"python","code":"\n                idx=numpy.argpartition(-arr,kth=3,axis=1)\n                print(idx)\n                # [[3 4 2 1 0]\n                #  [3 0 4 2 1]\n                #  [0 4 1 3 2]\n                #  [3 4 2 0 1]]\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"第二步，我们只留下前<code class=\"x-inline-highlight\">k</code>大的元素的索引："}}],["$","$Le",null,{"language":"python","code":"\n                idx=idx.take(indices=range(3),axis=1)\n                print(idx)\n                # [[3 4 2]\n                #  [3 0 4]\n                #  [0 4 1]\n                #  [3 4 2]]\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"第三步，需要通过<code class=\"x-inline-highlight\">numpy.take_along_axis</code>函数得到按<code class=\"x-inline-highlight\">idx</code>排列的数组。"}}],["$","$Le",null,{"language":"python","code":"\n                val=numpy.take_along_axis(arr,indices=idx,axis=1)\n                print(val)\n                # [[7 8 5]\n                #  [8 9 4]\n                #  [8 6 5]\n                #  [6 5 4]]\n                "}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"到现在为止，我们已经得到了<span class=\"x-inline-strong\">乱序</span>的数组值和索引值，因此最后一步是使用<code class=\"x-inline-highlight\">numpy.argsort</code>进行排序。"}}],["$","$Le",null,{"language":"python","code":"\n                sorted_idx=numpy.argsort(-val,axis=1)\n                idx=numpy.take_along_axis(idx,indices=sorted_idx,axis=1)\n                val=numpy.take_along_axis(val,indices=sorted_idx,axis=1)\n\n                print(val)\n                # [[8 7 5]\n                #  [9 8 4]\n                #  [8 6 5]\n                #  [6 5 4]]\n\n                print(idx)\n                # [[4 3 2]\n                #  [0 3 4]\n                #  [0 4 1]\n                #  [3 4 2]]\n                "}],["$","$Lf",null,{"children":"封装"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"我们可以在numpy中封装一个和torch的<code class=\"x-inline-highlight\">topk</code>类似的函数："}}],["$","$Le",null,{"language":"python","code":"\n                def topk_numpy(arr,k,dim):\n                    idx=numpy.argpartition(-arr,kth=k,axis=dim)\n                    idx=idx.take(indices=range(k),axis=dim)\n                    val=numpy.take_along_axis(arr,indices=idx,axis=dim)\n                    sorted_idx=numpy.argsort(-val,axis=dim)\n                    idx=numpy.take_along_axis(idx,indices=sorted_idx,axis=dim)\n                    val=numpy.take_along_axis(val,indices=sorted_idx,axis=dim)\n                    return val,idx\n                "}],["$","div",null,{"className":"x-highlightblock highlight-background-golden","children":["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"这个函数只实现了torch库中<code class=\"x-inline-highlight\">topk</code>函数最基本的功能，并不全面~"}}]}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"检验一下是否正确："}}],["$","$Le",null,{"language":"python","code":"\n                bigarr=numpy.random.rand(64,16,24,24)\n                bigtsr=torch.tensor(bigarr)\n\n                val_t,idx_t=torch.topk(bigtsr,k=7,dim=1)\n                val_n,idx_n=topk_numpy(bigarr,k=7,dim=1)\n\n                print(val_n.shape) #(64, 7, 24, 24)\n                print(numpy.all(val_t.numpy()==val_n)) #True\n                print(numpy.all(idx_t.numpy()==idx_n)) #True\n                "}],["$","$Lf",null,{"children":"讨论"}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"上述方法核心是<span class=\"x-inline-strong\">先切片、再排序</span>。这是由于<code class=\"x-inline-highlight\">argpartition</code>和<code class=\"x-inline-highlight\">argsort</code>的性能差异："}}],["$","p",null,{"className":"x-p","dangerouslySetInnerHTML":{"__html":"<code class=\"x-inline-highlight\">argsort</code>对全部数组进行排序，而<code class=\"x-inline-highlight\">argpartition</code>只进行一次类似快速排序算法中的划分操作，因此<code class=\"x-inline-highlight\">argpartition</code>效率更高。对于<code class=\"x-inline-highlight\">topk</code>函数想要实现的功能，尽管先全排序、再切片从代码上更好编写，但当<code class=\"x-inline-highlight\">k</code>远小于<code class=\"x-inline-highlight\">dim</code>维度大小时，是较为低效的做法。"}}]],null],"segment":"__PAGE__"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f70c26425a044d6b.css","precedence":"next","crossOrigin":""}]]}],"segment":"torch-numpy-topk"},"styles":[]}],"segment":"24a"},"styles":[]}],"params":{}}],null],"segment":"(blogs)"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d1ba65e78d6f432c.css","precedence":"next","crossOrigin":""}]]}]]}]}]}],null]
c:null
