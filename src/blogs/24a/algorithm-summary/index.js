import X from 'src/component/X';

export default function Blog({title}) {
    return (
        <>
            <X.Title>{title}</X.Title>
            <X.P>
                在解决问题的时候，我的切身体会是，需要用到自己不会的方法并不可怕，总可以学习；难的是很多时候根本想不到需要用什么方法。---
                想象力一旦被局限在知识储备之内，有时就会对问题无从下手。
            </X.P>
            <X.P>
                因此我产生了写下这篇博客的想法，在本文只总结*各种算法或数据结构旨在解决的问题*，但并不会展开讲解每一种算法，---
                也没有代码实现——甚至很多算法对我而言都是极其陌生的。希望能通过这种方式开拓自己的思维，也能对同样在思索如何解决眼前问题的读者有所启发。
            </X.P>
            <X.P>本文梳理的内容绝大部分来自@OI Wiki[https://oi-wiki.org/]@，部分类别划分有改动。</X.P>
            <X.H1>搜索</X.H1>
            <X.H2>广搜BFS/深搜DFS</X.H2>
            <X.P>
                概念不再赘述。从功能的角度通俗地理解，广搜`(BFS)`可能更适合想要*求解最优解*的问题；而深搜`(DFS)`更适合*需要求出全部可行解*或需要*访问到全部可行状态*的问题。
            </X.P>
            <X.H2>深搜剪枝</X.H2>
            <X.P noMarginBottom>用于优化`DFS`算法的时间效率，常见的有：</X.P>
            <X.Uli>最优性剪枝：如果还没有搜索完，但发现当前解已经比*已有最优解*更差时，就可以停止搜索了。</X.Uli>
            <X.Uli>
                可行性剪枝：如果可以提前判断出当前解在未来一定不可行，就可以停止搜索，而不必“撞了南墙才回头”。
            </X.Uli>
            <X.P></X.P>
            <X.H2>A*</X.H2>
            <X.P>
                BFS不断地取出队首的状态，然后将可以拓展到的新状态加入队列。对于一些算法（例如`Dijkstra`），会维护一个优先队列，并给状态定义一个函数$f$，每次取这个函数值最大/最小的状态进行拓展。---
                例如`Dijkstra`算法中，这个函数$f$就是从起点到这个状态的最短距离。
            </X.P>
            <X.P>
                `A\*`算法的思想是将维护的函数$f$改为$g=f+h$，多出的这一项称为*启发函数*。这一项通常是对当前状态好坏的粗略评估，例如在求最短路的时候，可以用当前节点到终点的直线距离作为启发项。---
                由此，$g$函数相当于综合的考虑了当前状态的过去已有成本$f$，和未来预估成本$h$。
            </X.P>
            <X.P>
                如果启发函数的估计$h$总是优于真实的代价$h^\ast$，例如在最短路问题中，估计的直线距离一定小于等于真实距离，---
                也就是$h \leq h^\ast$。在这个条件下，`A\*`算法可以找到最优解。
            </X.P>
            <X.H2>迭代加深搜索IDDFS</X.H2>
            <X.P>
                迭代加深是一种*每次限制搜索深度的*深度优先搜索。迭代加深搜索预先设定一个深度$d$，如果在这个限制条件下不能找到合法解，就让$d$加一再搜索。
            </X.P>
            <X.P>
                在这个意义下，迭代加深搜索一般用于找最优解，就类似于用`DFS`方式实现的`BFS`。其目的是减小空间复杂度。---
                迭代加深搜索的确会重复的搜索前面的状态。但通常搜索树会呈指数增长，前面累计搜索的复杂度可以忽略。
            </X.P>
            <X.P>这就像：$1+2+4+8+\dots+2^n$也不过就是$2^n$的$2$倍左右。</X.P>
            <X.H2>IDA*</X.H2>
            <X.P>
                `IDA*`算法结合了`IDDFS`和`A*`算法的思想：`IDDFS`只是把搜索空间限制在$d$内，但假如可以对当前状态进行某种评估，如果评估值过大，就认为这个状态“不够好”，尽管目前没有超过限制，---
                但没有希望在限制内找到最优解，可以提前剪枝（也就是可行性剪枝）。
            </X.P>
            <X.H2>Minimax搜索</X.H2>
            <X.P>
                双人对弈中，构建一棵状态树，树中每一个节点都有一个分数，代表对一方的优势程度的某种评估（比如己方获胜概率等等）。---
                这棵树中奇数层为己方先手，偶数层为对方先手。双人都采取最优策略时，对于奇数层，我方会选择*最大*的分数，对于偶数层，对方会选择*最小*的分数。
            </X.P>
            <X.H2>alpha-beta剪枝</X.H2>
            <X.P>给`Minimax`搜索树的每个节点记录$\alpha$为最大下界，$\beta$为最小上界，并利用其进行剪枝。</X.P>
            <X.H1>动态规划</X.H1>
            <X.H1>字符串</X.H1>
            <X.H1>数据结构</X.H1>
            <X.H1>图论</X.H1>
            <X.H2>树的直径</X.H2>
            <X.P>求树上任意两节点之间最长的路径。</X.P>
            <X.H2>最近公共祖先LCA</X.H2>
            <X.P>求两个节点的公共祖先里面，离根最远的那个。</X.P>
            <X.H2>树的重心</X.H2>

            <X.H1>其他（数学，杂项）</X.H1>
            <X.H2>X算法和舞蹈链Dancing Links</X.H2>
            <X.P>舞蹈链`(Dancing Links)`是由Donald E. Knuth提出的数据结构，目的是快速实现他提出的的`X算法`。</X.P>
            <X.P>
                用于解决*精确覆盖问题*：例如，给定一个$0/1$矩阵，想求出一个行集合，使得每列*包含且恰好包含*一个$1$。
            </X.P>
            <X.P>
                此算法经过修改也可用于解决*重复覆盖问题*：给定一个$0/1$矩阵，想求出一个行数最少的行集合，使得每列*至少*包含一个$1$。
            </X.P>
        </>
    );
}
